# 🎯 嵌入式滤波算法：从入门到精通（大一学弟必看）


适合人群：电控新人、嵌入式初学者、对滤波算法一脸懵的崽芽子们

---

## 📖 前言：为啥要学滤波算法？

各位学弟好啊！老李我是你们学长（虽然我现在在五金店打工），今天来给你们讲讲嵌入式开发中最重要的技能之一——**滤波算法**。

你说啥？不知道滤波是个啥玩意儿？那老李我先给你打个比方：

想象一下，你买了个温度传感器，本来室温就是25℃对吧？结果这个憨批传感器给你读数：
```
25.1℃ → 24.8℃ → 100℃！→ 25.2℃ → 24.9℃
```

乖乖，那个100℃是啥情况？传感器抽风了？电磁干扰？还是你家着火了？

这就是**噪声**啊兄弟！在嵌入式的世界里，传感器数据就像在菜市场打电话——背景噪音一堆，你得学会"过滤"掉这些噪音，才能听清对方在说啥。

**滤波算法就是干这个的！** 它能把传感器数据里的"垃圾"（噪声）过滤掉，留下真正有用的信息。

---

## 🎬 正片开始：八大滤波算法全解析

老李我花了一整天时间，把嵌入式开发中最常用的8种滤波算法全部整理出来了。每一种都有详细的代码实现和应用场景。

废话不多说，开搞！

---

## 1️⃣ 一阶低通滤波（RC滤波）

### 🔍 一句话概括
**最简单粗暴的滤波器，一行代码搞定！**

### 📐 核心公式
```c
Y(n) = α × X(n) + (1-α) × Y(n-1)
```

翻译成人话就是：**新的输出 = 这次测量的一部分 + 上次输出的一部分**

### 💡 怎么理解？
你考试成绩不稳定，一会儿90分一会儿60分。老师用你最近5次考试的"加权平均"来评估你的真实水平——最新的成绩占30%，之前的成绩占70%。这就是一阶低通滤波的思想！

### ✅ 优点（为啥用它）
- ✨ **超级简单**：一个公式，5行代码，初中数学水平
- ⚡ **计算贼快**：只需要1次乘法和2次加法
- 💾 **内存占用小**：只需保存1个历史值（4字节）
- 🎯 **实时性好**：没有延迟，立刻就能算出结果

### ❌ 缺点（啥时候别用）
- 📉 **滤波效果一般**：对付强噪声有点吃力
- 🐌 **响应有点慢**：α设小了，信号变化跟不上
- 🚫 **处理不了突变**：真实信号突然变化时，输出会"拖后腿"

### 🎯 最佳应用场景
- 🌡️ **温度传感器**（α = 0.1~0.2）：温度变化慢，用小α值平滑
- 🔋 **电池电压监测**（α = 0.1~0.15）：电压变化很慢
- 📏 **距离传感器**（α = 0.2~0.3）：超声波、红外测距

### 💻 示例代码（超简单）
```c
float rc_filter(float new_value, float alpha) {
    static float output = 0.0f;
    output = alpha * new_value + (1.0f - alpha) * output;
    return output;
}

// 使用示例
float temp = read_temperature();        // 读传感器
float filtered_temp = rc_filter(temp, 0.2f);  // 滤波！
```

### 🎓 老李点评
> **这是入门首选！** 简单到你闭着眼睛都能写出来。虽然滤波效果不是最好的，但对付一般的小噪声绰绰有余。初学者必学，老手必用！

---

## 2️⃣ 中值滤波

### 🔍 一句话概括
**专治"脉冲干扰"的神器，能过滤掉那些突然冒出来的奇葩数据！**

### 📐 核心思想
把最近N次采样值**从小到大排序**，然后取**中间那个值**作为输出。

### 💡 怎么理解？
你最近5次测量温度：`25, 24, 26, 100, 25`

显然那个100是个异常值对吧？把这5个数排序：`24, 25, 25, 26, 100`，取中间的值：**25℃**

看到没？异常值100被自动忽略了！这就是中值滤波的牛逼之处！

### ✅ 优点（为啥用它）
- 💪 **脉冲干扰杀手**：对偶然出现的突变噪声效果极好
- 🛡️ **保护边缘信息**：不会像均值滤波那样把突变"抹平"
- 🎯 **输出真实**：输出值一定是实际采样值之一（不会产生"不存在的值"）

### ❌ 缺点（啥时候别用）
- 💻 **计算量大**：每次都要排序，窗口越大越慢
- 📉 **对高斯噪声效果一般**：连续的随机噪声还是用均值滤波好
- 🐌 **响应有延迟**：窗口大了，跟踪信号变化会变慢

### 🎯 最佳应用场景
- 📡 **ADC采样**（窗口长度5）：电源干扰导致的偶然跳变
- 🌡️ **传感器采集**（窗口长度5~7）：偶尔出现的异常读数
- ⌨️ **按键消抖**（窗口长度3~5）：机械抖动产生的伪信号

### 💻 示例代码（需要排序）
```c
#define WINDOW_SIZE 5

float median_filter(float new_value) {
    static float buffer[WINDOW_SIZE] = {0};
    static int index = 0;

    // 1. 更新缓冲区
    buffer[index] = new_value;
    index = (index + 1) % WINDOW_SIZE;

    // 2. 复制并排序（冒泡排序）
    float sorted[WINDOW_SIZE];
    memcpy(sorted, buffer, sizeof(buffer));
    for (int i = 0; i < WINDOW_SIZE-1; i++) {
        for (int j = 0; j < WINDOW_SIZE-i-1; j++) {
            if (sorted[j] > sorted[j+1]) {
                float temp = sorted[j];
                sorted[j] = sorted[j+1];
                sorted[j+1] = temp;
            }
        }
    }

    // 3. 返回中值
    return sorted[WINDOW_SIZE/2];
}
```

### 🎓 老李点评
> **传感器数据经常"抽风"？用它！** 中值滤波就像一个火眼金睛的守门员，能把那些"不正常"的数据一眼识破并踢出去。就是计算量稍微大了点儿，不过对现在的单片机来说完全不是问题。

---

## 3️⃣ 均值滤波（滑动平均）

### 🔍 一句话概括
**最朴实无华的滤波器，就是"求平均"，小学数学水平！**

### 📐 核心公式
```
Y = (X₁ + X₂ + X₃ + ... + Xₙ) / N
```

### 💡 怎么理解？
你最近10次考试成绩分别是：85, 90, 88, 92, 87...
老师用这10次成绩的**平均分**来评估你的水平。这就是均值滤波！

### ✅ 优点（为啥用它）
- 📝 **超级简单**：加法+除法，连代码都不用思考
- 📊 **平滑效果好**：能有效抑制随机噪声
- 💾 **资源占用小**：只需N个数据的存储空间

### ❌ 缺点（啥时候别用）
- 🐌 **响应速度慢**：新数据要等N次采样才能完全体现
- ⏱️ **相位滞后**：输出比输入延迟 N/2 个周期
- 💥 **对脉冲干扰无效**：一个异常值会持续影响N次

### 🎯 最佳应用场景
- 🌡️ **温度监测**（N = 5~10）：变化慢，可以多平滑一会儿
- 🔋 **电压监测**（N = 10~20）：电压变化很慢
- 💡 **光照强度**（N = 10~15）：环境光变化缓慢

### 💻 示例代码（两种实现）
```c
// 方法1：每次遍历求和（简单但慢）
float average_filter_v1(float new_value) {
    static float buffer[10] = {0};
    static int index = 0;

    buffer[index] = new_value;
    index = (index + 1) % 10;

    float sum = 0;
    for (int i = 0; i < 10; i++) {
        sum += buffer[i];
    }
    return sum / 10.0f;
}

// 方法2：增量更新（快！）
float average_filter_v2(float new_value) {
    static float buffer[10] = {0};
    static int index = 0;
    static float sum = 0;

    sum = sum - buffer[index] + new_value;  // 减去旧值，加上新值
    buffer[index] = new_value;
    index = (index + 1) % 10;

    return sum / 10.0f;
}
```

### 🎓 老李点评
> **适合"佛系"信号。** 啥叫佛系？就是那种慢悠悠的信号，比如温度、湿度。如果你的信号变化很快，或者经常有脉冲干扰，那还是用别的算法吧。均值滤波虽然简单，但"慢热"是它的硬伤。

---

## 4️⃣ 卡尔曼滤波

### 🔍 一句话概括
**滤波界的"扛把子"，数学上的最优解，但也是最难理解的！**

### 📐 核心思想
**预测 + 测量 = 最优估计**

卡尔曼滤波有两个步骤：
1. **预测阶段**：根据物理模型预测当前状态
2. **更新阶段**：结合传感器测量值修正预测

### 💡 怎么理解？
你在黑暗中扔飞镖：
- 你看不清飞镖在哪儿（测量有误差）
- 但你知道飞镖的运动规律（物理模型）

卡尔曼滤波就像一个聪明的助手，它会：
1. 根据物理规律**预测**飞镖应该在哪里
2. 结合你的**测量值**（虽然有误差）
3. 综合这两个信息，给出**最优估计**

### ✅ 优点（为啥用它）
- 🏆 **数学最优**：在线性系统+高斯噪声条件下，理论上是最优的
- ♻️ **递归计算**：不需要存储历史数据，只需上一次估计
- 💾 **内存效率高**：占用内存极小
- 🔮 **能预测未来**：不仅能滤波，还能预测下一时刻的状态

### ❌ 缺点（啥时候别用）
- 📚 **需要系统模型**：你得知道系统的物理规律
- 🎛️ **参数难调**：Q和R两个参数，新手容易懵
- 🔢 **计算复杂**：比简单滤波器复杂得多
- 📐 **只适用线性系统**：非线性系统需要扩展版本（EKF）

### 🎯 最佳应用场景
- ✈️ **无人机姿态估计**：融合加速度计、陀螺仪、磁力计
- 📍 **GPS定位优化**：融合GPS和惯性测量单元
- 🔋 **电池电量估计**：比库仑计数法更准确
- 🎮 **电机速度控制**：滤除编码器噪声

### 💻 示例代码（简化一维版本）
```c
typedef struct {
    float x;  // 状态估计值
    float P;  // 估计误差协方差
    float Q;  // 过程噪声协方差
    float R;  // 测量噪声协方差
    float K;  // 卡尔曼增益
} KalmanFilter;

void kalman_init(KalmanFilter *kf, float Q, float R) {
    kf->x = 0.0f;
    kf->P = 1.0f;
    kf->Q = Q;  // 通常 0.001~0.1
    kf->R = R;  // 通常 0.01~10
}

float kalman_update(KalmanFilter *kf, float measurement) {
    // 1. 预测
    // x̂(k|k-1) = x̂(k-1|k-1)  (假设是恒定系统)
    // P(k|k-1) = P(k-1|k-1) + Q
    kf->P = kf->P + kf->Q;

    // 2. 计算卡尔曼增益
    // K = P(k|k-1) / (P(k|k-1) + R)
    kf->K = kf->P / (kf->P + kf->R);

    // 3. 更新估计
    // x̂(k|k) = x̂(k|k-1) + K × [z(k) - x̂(k|k-1)]
    kf->x = kf->x + kf->K * (measurement - kf->x);

    // 4. 更新误差协方差
    // P(k|k) = (1 - K) × P(k|k-1)
    kf->P = (1 - kf->K) * kf->P;

    return kf->x;
}
```

### 🎓 老李点评
> **滤波界的"王炸"！** 效果牛逼，但学习曲线陡峭。如果你的项目要求高精度、需要融合多个传感器，那卡尔曼滤波绝对是第一选择。但如果你是新手，建议先把前面几个简单算法玩熟练了再来挑战它。

---

## 5️⃣ 互补滤波

### 🔍 一句话概括
**卡尔曼滤波的"简化版"，效果不错但简单得多，是姿态估计的首选！**

### 📐 核心公式
```c
angle = α × (angle + gyro × dt) + (1-α) × accel
```

### 💡 怎么理解？
你有两个传感器：
- **陀螺仪**：短期准确（响应快），长期漂移（会累积误差）
- **加速度计**：长期准确（测静态角度很准），短期不稳（容易受振动干扰）

互补滤波就是：**95%相信陀螺仪的短期数据 + 5%相信加速度计的长期数据**

### ✅ 优点（为啥用它）
- ⚡ **计算极简**：一次乘法、一次加法，比卡尔曼简单太多
- 🚀 **实时性极佳**：适合控制周期<10ms的高频控制
- 🎯 **效果不错**：对简单姿态估计已经足够精确
- 🔧 **只需调1个参数**：α值（通常0.95~0.98）

### ❌ 缺点（啥时候别用）
- 📐 **只适合小角度**：大角度旋转时精度下降
- 🏃 **无法处理剧烈运动**：加速度计在加速运动时测量不准
- 🎚️ **精度有限**：比卡尔曼滤波精度低
- 🔧 **需要手动调参**：α值需要根据应用场景调节

### 🎯 最佳应用场景
- 🚁 **无人机姿态控制**（α = 0.96~0.98）：四旋翼飞行器
- 🤖 **平衡车/平衡机器人**（α = 0.95）：单轴倾角控制
- 📸 **手持稳定器/云台**（α = 0.92~0.95）：相机防抖

### 💻 示例代码（超简单）
```c
float complementary_filter(float gyro_rate, float accel_angle, float dt) {
    static float angle = 0.0f;
    float alpha = 0.96f;

    // angle = 96%陀螺仪积分 + 4%加速度计
    angle = alpha * (angle + gyro_rate * dt) + (1 - alpha) * accel_angle;

    return angle;
}

// 使用示例
float gyro = read_gyro();      // 读陀螺仪角速度
float accel = read_accel();    // 读加速度计角度
float dt = 0.01f;              // 采样周期10ms

float angle = complementary_filter(gyro, accel, dt);
```

### 🎓 老李点评
> **姿态估计的"性价比之王"！** 如果你在做四轴飞行器、平衡车这类项目，用互补滤波就对了。它计算简单到你想哭，效果还不错，调参也容易。当然，如果你要做航天器那种高精度姿态控制，还是老老实实用卡尔曼吧。

---

## 6️⃣ 限幅滤波

### 🔍 一句话概括
**最简单粗暴的滤波器（之一），就两行代码：变化大了就拒绝，变化小了就接受！**

### 📐 核心思想
```
如果 |新值 - 旧值| > 限幅值:
    输出 = 旧值  # 拒绝！
否则:
    输出 = 新值  # 接受！
```

### 💡 怎么理解？
你在测室温，正常情况下温度变化很慢，比如从25℃到25.5℃。

突然测到一个40℃！这明显不合理（可能是传感器受干扰），直接忽略它，继续用上次的25.5℃！

这就是限幅滤波：**"合理就接受，不合理就拒绝"**

### ✅ 优点（为啥用它）
- 💨 **极其简单**：一次减法+一次比较，2行代码搞定
- ⚡ **计算量最小**：比所有其他滤波器都快
- 💾 **内存占用少**：只需1个历史值（4字节）
- 🚀 **零延迟**：实时性最好

### ❌ 缺点（啥时候别用）
- 🏃 **无法跟踪快速变化**：真实信号变化快时，会被误判为干扰
- 🎚️ **参数难选**：限幅值设大了没用，设小了丢失真实变化
- 📉 **不能滤除随机噪声**：对小幅度噪声完全无效
- ⏸️ **可能产生停滞**：连续超限会导致输出一直不变

### 🎯 最佳应用场景
- 🌡️ **温度监测**（限幅值 1~3℃）：温度变化缓慢
- 🔋 **电池电压**（限幅值 0.1~0.5V）：电压变化很慢
- 📏 **液位检测**（限幅值 量程的2~10%）：液位变化缓慢

### 💻 示例代码（真的很简单）
```c
float limit_filter(float new_value, float limit) {
    static float last_value = 0.0f;
    static int first_run = 1;

    if (first_run) {
        last_value = new_value;
        first_run = 0;
        return new_value;
    }

    // 计算差值
    float diff = fabs(new_value - last_value);

    // 判断是否超限
    if (diff <= limit) {
        last_value = new_value;  // 接受
        return new_value;
    } else {
        return last_value;        // 拒绝，保持旧值
    }
}

// 使用示例
float temp = read_temperature();
float filtered = limit_filter(temp, 2.0f);  // 限幅值2℃
```

### 🎓 老李点评
> **适合"懒人"和"资源紧张"的场合。** 如果你的信号变化很慢、偶尔有脉冲干扰、而且单片机资源紧张，那限幅滤波是个不错的选择。但千万别指望它能处理复杂情况，它就是个"门卫"，只负责把明显不合理的数据挡在门外。

---

## 7️⃣ 滞环滤波

### 🔍 一句话概括
**专治"抖动"的神器，给信号加一个"死区"，小变化全部无视！**

### 📐 核心思想
```
如果 |新值 - 输出| > 阈值:
    输出 = 新值  # 变化够大，更新！
否则:
    输出保持不变  # 变化太小，无视！
```

### 💡 怎么理解？
想象你家空调温控：
- 设定26℃
- 温度到27℃时开始制冷
- 温度到25℃时停止制冷
- 在25~27℃之间不会频繁开关

这就是滞环！在"死区"内的小波动全部忽略，避免频繁切换。

### ✅ 优点（为啥用它）
- 🛡️ **极强抗噪能力**：小幅噪声被完全屏蔽
- ⚡ **计算极快**：一次减法+一次比较
- 💾 **内存占用小**：只需1个历史值
- 🎚️ **消除抖动**：特别适合开关量信号

### ❌ 缺点（啥时候别用）
- 📉 **信号失真**：会丢失小于阈值的真实变化
- 📊 **输出不平滑**：输出呈阶跃状
- 🎯 **不适合连续信号**：需要精确跟踪的信号别用它

### 🎯 最佳应用场景
- ⌨️ **按键消抖**（阈值 5~20次）：消除机械抖动
- 🌡️ **温度控制**（阈值 1℃）：空调、加热器开关控制
- 💧 **液位检测**（阈值 5~8cm）：水箱高低液位报警
- 🔋 **电压报警**（阈值 0.1~0.2V）：低电量警告

### 💻 示例代码（超级简单）
```c
float hysteresis_filter(float new_value, float threshold) {
    static float output = 0.0f;
    static int first_run = 1;

    if (first_run) {
        output = new_value;
        first_run = 0;
        return output;
    }

    // 计算差值
    float diff = fabs(new_value - output);

    // 超过阈值才更新
    if (diff > threshold) {
        output = new_value;
    }
    // 否则保持不变

    return output;
}

// 使用示例
float temp = read_temperature();
float stable_temp = hysteresis_filter(temp, 1.0f);  // 阈值1℃

if (stable_temp > 27.0f) {
    turn_on_cooling();  // 开始制冷
} else if (stable_temp < 25.0f) {
    turn_off_cooling(); // 停止制冷
}
```

### 🎓 老李点评
> **按键消抖首选！** 滞环滤波就像给信号装了个"懒惰开关"，小变化？不管！只有变化够大了才理你。特别适合那些需要稳定状态切换的场合，比如按键、开关、报警器。但如果你需要精确的信号波形，那还是算了吧。

---

## 8️⃣ 巴特沃斯滤波

### 🔍 一句话概括
**频域滤波的"王者"，工程上最常用的IIR滤波器，特点是通带最平坦！**

### 📐 核心特性
巴特沃斯滤波器在**通带内频率响应最平坦**，没有波纹。

差分方程（二阶）：
```c
y[n] = a0×x[n] + a1×x[n-1] + a2×x[n-2] - b1×y[n-1] - b2×y[n-2]
```

### 💡 怎么理解？
想象你在调节音响的音量旋钮：
- **简单滤波器**：旋钮转一点儿，音量跳一大截（不平滑）
- **巴特沃斯滤波器**：旋钮转一点儿，音量也变一点儿（超平滑）

巴特沃斯滤波器就像一个"温柔的音量调节器"，让频率响应平滑、均匀，没有突变。

### ✅ 优点（为啥用它）
- 📏 **通带最平坦**：在通带内幅度响应最均匀，失真小
- 🎯 **特性可预测**：数学模型清晰，参数设计简单
- ⚡ **计算效率高**：二阶滤波器只需5个乘法、4个加法
- 🔧 **易于级联**：可通过级联实现更高阶滤波

### ❌ 缺点（啥时候别用）
- 📉 **过渡带较宽**：从通带到阻带的过渡不够陡峭
- 🔢 **需要浮点运算**：系数通常是浮点数
- ⚙️ **参数调节复杂**：需要设置截止频率和采样频率

### 🎯 最佳应用场景
- 📡 **传感器信号处理** ⭐⭐⭐⭐⭐：温度、压力、加速度、陀螺仪
- 🔌 **电源滤波** ⭐⭐⭐⭐：ADC参考电压、电池电压监测
- 🎵 **音频信号处理** ⭐⭐⭐⭐：低音增强、高音去除
- 📶 **通信系统** ⭐⭐⭐：基带信号滤波、抗混叠滤波

### 💻 示例代码（二阶低通）
```c
typedef struct {
    float a0, a1, a2;  // 前向系数
    float b1, b2;      // 反馈系数
    float x1, x2;      // 历史输入
    float y1, y2;      // 历史输出
} ButterworthFilter;

void butterworth_init(ButterworthFilter *f, float fc, float fs) {
    // fc: 截止频率, fs: 采样频率
    float wd = fc / fs;
    float wa = tan(3.14159f * wd);
    float Q = 0.7071f;  // 二阶巴特沃斯固定值

    float K = wa;
    float norm = 1.0f / (1.0f + K / Q + K * K);

    f->a0 = K * K * norm;
    f->a1 = 2.0f * f->a0;
    f->a2 = f->a0;
    f->b1 = 2.0f * (K * K - 1.0f) * norm;
    f->b2 = (1.0f - K / Q + K * K) * norm;

    f->x1 = f->x2 = f->y1 = f->y2 = 0.0f;
}

float butterworth_update(ButterworthFilter *f, float input) {
    float output = f->a0 * input +
                   f->a1 * f->x1 +
                   f->a2 * f->x2 -
                   f->b1 * f->y1 -
                   f->b2 * f->y2;

    // 更新历史数据
    f->x2 = f->x1;
    f->x1 = input;
    f->y2 = f->y1;
    f->y1 = output;

    return output;
}

// 使用示例
ButterworthFilter filter;
butterworth_init(&filter, 5.0f, 100.0f);  // fc=5Hz, fs=100Hz

while (1) {
    float raw = read_sensor();
    float filtered = butterworth_update(&filter, raw);
    // ...
}
```

### 🎓 老李点评
> **滤波界的"全能选手"！** 巴特沃斯滤波器是工程师的最爱，因为它在各种场合都表现不错。虽然不是每个指标都最优，但综合性能很均衡。如果你需要高质量的滤波效果、对相位失真要求不是特别严格，那巴特沃斯绝对是首选。

---

## 📊 八大算法全面对比

老李我把这8个算法的各项指标都整理成表格了，方便你们选择：

### 🎯 性能对比表（满分⭐⭐⭐⭐⭐）

| 算法 | 滤波效果 | 响应速度 | 计算复杂度 | 内存占用 | 易用性 | 适用场景 |
|------|---------|---------|----------|---------|--------|---------|
| 一阶低通 | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 通用 |
| 中值滤波 | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 脉冲干扰 |
| 均值滤波 | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 缓慢信号 |
| 卡尔曼滤波 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐ | 高精度系统 |
| 互补滤波 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 姿态估计 |
| 限幅滤波 | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 缓变+脉冲 |
| 滞环滤波 | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 开关控制 |
| 巴特沃斯 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | 传感器+音频 |

### 🎭 选择决策树

```
你的应用场景是什么？
│
├─ 【温度/湿度/气压等缓变信号】
│  ├─ 偶有脉冲干扰 → 中值滤波 or 限幅滤波
│  └─ 持续随机噪声 → 均值滤波 or 一阶低通
│
├─ 【加速度计/陀螺仪等传感器】
│  ├─ 需要融合多个传感器 → 卡尔曼滤波
│  ├─ 姿态估计（小角度） → 互补滤波
│  └─ 单传感器降噪 → 巴特沃斯滤波
│
├─ 【按键/开关等数字信号】
│  └─ 消除抖动 → 滞环滤波 or 中值滤波
│
├─ 【电池电压/ADC采样】
│  ├─ 变化极慢 → 均值滤波 or 限幅滤波
│  └─ 需要高精度 → 一阶低通 or 巴特沃斯
│
└─ 【音频/通信信号】
   └─ 频域滤波 → 巴特沃斯滤波
```

### 💡 组合使用建议

很多时候，单一滤波器效果不够好，可以**组合使用**：

1. **限幅滤波 + 均值滤波**
   ```c
   float raw = read_sensor();
   float limited = limit_filter(raw, 5.0f);      // 先去脉冲
   float smoothed = average_filter(limited);      // 再平滑
   ```

2. **中值滤波 + 一阶低通**
   ```c
   float raw = read_sensor();
   float median = median_filter(raw);             // 先去脉冲
   float smooth = rc_filter(median, 0.3f);        // 再平滑
   ```

3. **互补滤波 + 卡尔曼滤波**（高级融合）
   ```c
   // 互补滤波粗略估计，卡尔曼滤波精细优化
   float angle_comp = complementary_filter(...);
   float angle_kalman = kalman_update(&kf, angle_comp);
   ```

---

## 🎓 老李的经验总结

### 新手入门推荐
1. **先学一阶低通**：最简单，3分钟学会
2. **再学中值滤波**：处理脉冲干扰神器
3. **然后学均值滤波**：理解"平均"的威力
4. **最后挑战卡尔曼**：登顶滤波算法之巅

### 项目实战建议
- 🔰 **初级项目**（智能家居、简单机器人）：一阶低通 + 中值滤波足够
- 🔶 **中级项目**（平衡车、四轴飞行器）：互补滤波 or 简化卡尔曼
- 🔥 **高级项目**（自动驾驶、精密控制）：扩展卡尔曼 + 巴特沃斯

### 调参黄金法则
1. **从简单开始**：先用默认参数跑起来
2. **观察波形**：用串口或示波器看实际效果
3. **小步调整**：每次只改一个参数
4. **记录数据**：好参数值记下来，下次直接用

### 避坑指南
- ❌ **别盲目追求复杂算法**：能用简单的就别用复杂的
- ❌ **别忽视采样频率**：采样太慢，啥滤波器都没用
- ❌ **别忘记初始化**：很多bug都是因为没初始化
- ❌ **别一个滤波器走天下**：不同场景用不同算法

---

## 📚 学习资源推荐

### 代码实现
本文所有算法的完整代码都在 `滤波算法汇总` 文件夹里：
- `01_一阶低通滤波.c/.md`
- `02_中值滤波.c/.md`
- `03_均值滤波.c/.md`
- `04_卡尔曼滤波.c/.md`
- `05_互补滤波.c/.md`
- `06_限幅滤波.c/.md`
- `07_滞环滤波.c/.md`
- `08_巴特沃斯滤波.c/.md`

每个文件都有：
- ✅ 详细的原理讲解
- ✅ 完整的C语言实现
- ✅ 实际应用示例
- ✅ 参数调节建议

### 进阶书籍
- 《数字信号处理》 - 高等教育出版社
- 《卡尔曼滤波原理及应用》 - 付梦印等著
- 《嵌入式系统设计》 - 清华大学出版社

---

## 🎉 结语

好了学弟们，老李我这篇文章写了整整一天（五金店老板都骂我摸鱼了），把8种常用滤波算法全给你们讲明白了。

**记住老李的话**：
- 📌 **没有最好的算法，只有最合适的算法**
- 📌 **先把简单算法玩熟练，再去挑战复杂算法**
- 📌 **实践是检验真理的唯一标准，多动手写代码！**

滤波算法就像做菜的调料，用对了能让你的项目"色香味俱全"，用错了就是"黑暗料理"。希望这篇文章能帮到你们！

有问题的话，欢迎在评论区留言，老李我有空会回复的。

**祝大家代码无Bug，项目一次过！**
