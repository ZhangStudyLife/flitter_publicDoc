# 滞环滤波算法详解

## 一、算法原理

### 1.1 什么是滞环滤波？

滞环滤波（Hysteresis Filter）是一种基于"滞后效应"的数字滤波算法。它的核心思想是：**只有当新采样值与当前输出值的差值超过一定阈值时，才更新输出值**。这就像一个"死区"，小幅度的波动会被忽略，只有足够大的变化才会被响应。

想象一下空调的温度控制：
- 设定温度是26℃
- 当温度升到27℃时开始制冷
- 当温度降到25℃时停止制冷
- 在25℃~27℃之间不会频繁开关

这就是滞环的原理！

### 1.2 数学原理

滞环滤波的数学模型如下：

设：
- `x(n)` 为当前采样值
- `y(n)` 为当前输出值
- `y(n-1)` 为上一次输出值
- `ε` 为滞环阈值（死区宽度）

滤波规则：

```
if |x(n) - y(n-1)| > ε:
    y(n) = x(n)        # 差值超过阈值，更新输出
else:
    y(n) = y(n-1)      # 差值在阈值内，保持不变
```

用分段函数表示：

$$
y(n) = \begin{cases}
x(n), & \text{if } |x(n) - y(n-1)| > \varepsilon \\
y(n-1), & \text{if } |x(n) - y(n-1)| \leq \varepsilon
\end{cases}
$$

### 1.3 工作机制图解

```
采样值变化示意图：

   ┌─────────────────────────────────────┐
   │  阈值区间（死区）                    │
   │     ↓                                │
   │  y ± ε                               │
   │                                      │
输│  ────────────── y+ε (上限)           │
出│                                      │
值│  ══════════════ y   (当前输出)       │
   │                                      │
   │  ────────────── y-ε (下限)           │
   │                                      │
   └─────────────────────────────────────┘
        时间 →

说明：
- 只要新采样值在 [y-ε, y+ε] 区间内，输出保持不变
- 当新采样值超出这个区间时，输出才会跳变到新值
```

### 1.4 滞环特性

滞环滤波具有明显的"记忆效应"：
1. **状态保持**：一旦进入某个状态，会保持到变化足够大
2. **抗抖动**：小幅波动不会导致输出变化
3. **快速响应**：大幅变化能立即响应

---

## 二、C语言实现

### 2.1 基本版本

```c
/**
 * @brief 滞环滤波器
 * @param new_value 当前采样值
 * @param threshold 滞环阈值（死区宽度）
 * @return 滤波后的输出值
 */
float hysteresis_filter(float new_value, float threshold)
{
    static float output = 0.0f;        // 静态变量保存上次输出
    static int first_run = 1;           // 首次运行标志

    // 首次运行，直接初始化
    if (first_run) {
        output = new_value;
        first_run = 0;
        return output;
    }

    // 计算差值的绝对值
    float diff = new_value - output;
    if (diff < 0) diff = -diff;         // 取绝对值

    // 判断是否超过阈值
    if (diff > threshold) {
        output = new_value;              // 更新输出
    }
    // 否则保持原值（output不变）

    return output;
}
```

### 2.2 增强版本（带初始化和重置）

```c
/**
 * @brief 滞环滤波器结构体
 */
typedef struct {
    float output;           // 当前输出值
    float threshold;        // 滞环阈值
    int initialized;        // 初始化标志
} HysteresisFilter;

/**
 * @brief 初始化滞环滤波器
 * @param filter 滤波器指针
 * @param threshold 滞环阈值
 */
void hysteresis_init(HysteresisFilter *filter, float threshold)
{
    filter->output = 0.0f;
    filter->threshold = threshold;
    filter->initialized = 0;
}

/**
 * @brief 滞环滤波更新
 * @param filter 滤波器指针
 * @param new_value 新采样值
 * @return 滤波后的输出值
 */
float hysteresis_update(HysteresisFilter *filter, float new_value)
{
    // 首次运行，直接使用新值初始化
    if (!filter->initialized) {
        filter->output = new_value;
        filter->initialized = 1;
        return filter->output;
    }

    // 计算差值绝对值
    float diff = new_value - filter->output;
    if (diff < 0) diff = -diff;

    // 判断是否超过阈值
    if (diff > filter->threshold) {
        filter->output = new_value;
    }

    return filter->output;
}

/**
 * @brief 重置滤波器
 * @param filter 滤波器指针
 */
void hysteresis_reset(HysteresisFilter *filter)
{
    filter->output = 0.0f;
    filter->initialized = 0;
}
```

---

## 三、优缺点分析

### 3.1 优点

| 优点 | 说明 |
|------|------|
| **极强的抗噪能力** | 小幅度噪声被完全抑制，输出非常稳定 |
| **计算量极小** | 只需一次减法和一次比较，资源占用最少 |
| **内存占用小** | 只需保存一个历史输出值 |
| **参数简单** | 只有一个阈值参数，易于理解和调节 |
| **快速响应** | 对大幅度变化能立即响应，无延迟 |
| **消除抖动** | 特别适合消除开关量信号的抖动 |

### 3.2 缺点

| 缺点 | 说明 |
|------|------|
| **信号失真** | 会"丢失"小于阈值的真实变化 |
| **阶跃响应差** | 输出呈阶跃状，不平滑 |
| **参数敏感** | 阈值设置不当会导致效果很差 |
| **不适合连续信号** | 对需要精确跟踪的连续信号不适用 |
| **无法滤除大噪声** | 超过阈值的噪声会直接通过 |

### 3.3 与其他算法的对比

```
滤波效果对比：

原始信号:  ∿∿∿∿∿∿∿∿∿∿∿∿∿∿  （带小幅噪声）
           ↓ 不同滤波器

均值滤波:  ~~~~~  （平滑但有延迟）

中值滤波:  ～～～  （较平滑，有延迟）

滞环滤波:  ─────  （完全平直，噪声被抑制）
```

---

## 四、适用场景

### 4.1 最佳应用场景

#### 1. **按键消抖**（最经典应用）

```c
// 按键状态检测
#define KEY_THRESHOLD 10    // 10次采样变化才确认

int key_state = key_scan();
int filtered_state = hysteresis_update(&key_filter, key_state);
```

**为什么适合？**
- 按键按下/释放时会有机械抖动
- 滞环滤波能确保稳定的状态切换
- 防止误触发

#### 2. **开关量信号处理**

```c
// 液位检测
float level = read_water_level();
int level_alarm = hysteresis_update(&level_filter, level);

// 温度报警
float temp = read_temperature();
int temp_alarm = hysteresis_update(&temp_filter, temp);
```

**应用示例：**
- 温度控制：设定26℃，实际在25.5~26.5℃之间波动，滞环阈值设为0.5℃
- 液位检测：设定高水位80cm，滞环阈值5cm，避免在80cm附近频繁报警

#### 3. **传感器数据稳定**

```c
// 距离传感器（短距离测量易受干扰）
float distance = read_distance_sensor();
float stable_distance = hysteresis_update(&dist_filter, distance);
```

#### 4. **状态机中的状态切换**

```c
// 电池电压监测
typedef enum {
    BATT_FULL,      // > 4.0V
    BATT_NORMAL,    // 3.5~4.0V
    BATT_LOW        // < 3.5V
} BattState;

float voltage = read_battery_voltage();
float stable_voltage = hysteresis_update(&batt_filter, voltage);
BattState state = get_battery_state(stable_voltage);
```

### 4.2 不适用场景

| 场景 | 原因 | 推荐算法 |
|------|------|---------|
| 需要精确波形的信号 | 会丢失细节 | 低通滤波、卡尔曼滤波 |
| 音频信号处理 | 会严重失真 | IIR/FIR滤波器 |
| 高精度测量 | 小变化被忽略 | 卡尔曼滤波 |
| 快速变化的信号 | 响应不够灵敏 | 限幅滤波 |

---

## 五、参数调节建议

### 5.1 阈值选择原则

```
阈值大小的影响：

阈值过小 (ε → 0):
├─ 优点：灵敏度高，能捕捉小变化
└─ 缺点：抗噪能力弱，可能失效

阈值适中 (ε = 2~3倍噪声幅度):
├─ 优点：平衡灵敏度和稳定性
└─ 缺点：需要了解噪声特性

阈值过大 (ε → ∞):
├─ 优点：输出极其稳定
└─ 缺点：丢失真实信号变化
```

### 5.2 实用调节步骤

#### 步骤1：测量噪声幅度

```c
// 在稳定状态下采集100个样本
float samples[100];
for (int i = 0; i < 100; i++) {
    samples[i] = read_sensor();
    delay_ms(10);
}

// 计算最大偏差
float max_noise = calculate_max_deviation(samples);
printf("噪声幅度: %.2f\n", max_noise);
```

#### 步骤2：设置初始阈值

```c
// 推荐：阈值 = 2~3倍噪声幅度
float threshold = max_noise * 2.5;
hysteresis_init(&filter, threshold);
```

#### 步骤3：实测调整

```
测试场景              建议阈值
─────────────────────────────────────
按键消抖              5~20（采样次数）
温度控制（±0.5℃噪声） 1.0~1.5℃
液位检测（±2cm噪声）   5~8cm
电压监测（±50mV噪声）  100~150mV
距离传感（±1cm噪声）   2~3cm
```

### 5.3 自适应阈值（高级技巧）

对于噪声变化较大的场景，可以动态调整阈值：

```c
/**
 * @brief 自适应滞环滤波
 */
float adaptive_hysteresis(float new_value, float base_threshold)
{
    static float output = 0.0f;
    static float noise_estimate = 0.0f;

    // 估计噪声水平（简单的滑动平均）
    float diff = new_value - output;
    noise_estimate = 0.9 * noise_estimate + 0.1 * fabs(diff);

    // 动态阈值 = 基础阈值 + 噪声估计
    float adaptive_threshold = base_threshold + 2.0 * noise_estimate;

    if (fabs(diff) > adaptive_threshold) {
        output = new_value;
    }

    return output;
}
```

### 5.4 常见问题与解决

#### 问题1：输出长时间不变

**原因**：阈值设置过大
**解决**：逐步减小阈值，直到能响应正常变化

```c
// 调试代码
float test_thresholds[] = {5.0, 2.0, 1.0, 0.5};
for (int i = 0; i < 4; i++) {
    hysteresis_init(&filter, test_thresholds[i]);
    // 测试响应...
}
```

#### 问题2：输出仍然抖动

**原因**：阈值设置过小或噪声超过预期
**解决**：
1. 增大阈值
2. 在滞环滤波前加一级均值滤波

```c
// 组合滤波
float averaged = moving_average_filter(raw_value);
float stable = hysteresis_filter(averaged, threshold);
```

#### 问题3：响应延迟

**原因**：滞环滤波不会产生延迟，可能是采样频率太低
**解决**：提高采样频率

---

## 六、完整应用示例

### 示例1：温控系统

```c
// 空调控制系统
#define TARGET_TEMP 26.0f
#define HYSTERESIS  1.0f     // 1度滞环

HysteresisFilter temp_filter;
hysteresis_init(&temp_filter, HYSTERESIS);

void air_conditioner_control(void)
{
    float current_temp = read_temperature();
    float stable_temp = hysteresis_update(&temp_filter, current_temp);

    if (stable_temp > TARGET_TEMP + HYSTERESIS/2) {
        turn_on_cooling();
    }
    else if (stable_temp < TARGET_TEMP - HYSTERESIS/2) {
        turn_off_cooling();
    }
}
```

### 示例2：多级报警

```c
// 油箱液位监测
typedef enum {
    LEVEL_HIGH,     // 高液位
    LEVEL_NORMAL,   // 正常
    LEVEL_LOW,      // 低液位
    LEVEL_CRITICAL  // 危险液位
} LevelState;

HysteresisFilter level_filter;
hysteresis_init(&level_filter, 5.0);  // 5cm滞环

LevelState check_fuel_level(void)
{
    float level = read_fuel_level();
    float stable_level = hysteresis_update(&level_filter, level);

    if (stable_level > 80.0) return LEVEL_HIGH;
    if (stable_level > 30.0) return LEVEL_NORMAL;
    if (stable_level > 10.0) return LEVEL_LOW;
    return LEVEL_CRITICAL;
}
```

---

## 七、总结

### 7.1 核心要点

1. **滞环滤波是最简单的滤波算法**：一行代码就能实现核心功能
2. **专治"抖动"**：对开关量、状态切换特别有效
3. **参数关键**：阈值设置决定一切
4. **不适合连续信号**：会丢失细节，输出不平滑

### 7.2 使用建议

```
选择滞环滤波的判断标准：

✅ 使用滞环滤波的情况：
   □ 只关心信号是否超过某个阈值
   □ 需要消除小幅抖动
   □ 资源非常有限（RAM/CPU）
   □ 开关量信号处理

❌ 不使用滞环滤波的情况：
   □ 需要精确跟踪信号变化
   □ 信号的细节很重要
   □ 需要平滑的输出波形
   □ 音频或高精度测量
```

### 7.3 记忆口诀

```
滞环滤波记心间，
死区阈值是关键。
小信号全部滤，
大变化立即现。
按键消抖第一选，
开关控制也常见。
参数设置凭经验，
二到三倍噪声算。
```

---

## 八、扩展阅读

### 8.1 滞环与死区的区别

- **死区（Deadzone）**：小信号直接置零
- **滞环（Hysteresis）**：小变化时保持原值

### 8.2 双阈值滞环

更复杂的滞环可以设置上下两个不同的阈值：

```c
if (new_value > output + upper_threshold) {
    output = new_value;
}
else if (new_value < output - lower_threshold) {
    output = new_value;
}
```

### 8.3 在实际产品中的应用

- **智能家居**：温控器、光感开关
- **汽车电子**：油位传感器、温度报警
- **工业控制**：液位控制、压力开关
- **消费电子**：按键检测、电池管理

---

**参考资料：**
- 《数字信号处理基础》
- 《嵌入式系统设计》
- 《传感器信号处理实用技术》

---

*文档版本：v1.0*
*最后更新：2025年11月*
