/**
 ******************************************************************************
 * @file    02_中值滤波.c
 * @author  嵌入式滤波算法系列
 * @version V1.0
 * @date    2025-01-09
 * @brief   中值滤波算法实现
 ******************************************************************************
 * @description
 * 中值滤波是一种非线性滤波算法，通过对窗口内的数据排序并取中值来滤除
 * 脉冲干扰。特别适合处理传感器偶发的突变噪声。
 *
 * 主要特点：
 * 1. 对脉冲干扰（突变噪声）抑制能力强
 * 2. 能够保护信号的边缘信息
 * 3. 计算量比均值滤波大（需要排序）
 * 4. 输出值必定是窗口内某个实际采样值
 *
 * 适用场景：
 * - 传感器数据采集（温度、压力等）
 * - ADC采样信号滤波
 * - 脉冲计数器抗干扰
 * - 按键消抖
 ******************************************************************************
 */

#include <stdio.h>
#include <stdint.h>

/* ============================================================================
 *  配置参数
 * ============================================================================ */

/**
 * @brief 滤波窗口长度（取奇数效果更好）
 * @note  常用值：3, 5, 7, 9, 11
 *        - 窗口越大，滤波效果越好，但响应越慢
 *        - 窗口越小，响应越快，但滤波效果越弱
 *        - 推荐使用 5 或 7
 */
#define MEDIAN_FILTER_WINDOW    5

/* ============================================================================
 *  全局变量（滤波器内部状态）
 * ============================================================================ */

/**
 * @brief 滤波数据缓存（存储最近N次采样值）
 * @note  使用循环缓冲区的思想，不断更新最旧的数据
 */
static float filter_buffer[MEDIAN_FILTER_WINDOW] = {0};

/**
 * @brief 缓冲区索引（指向下一个要更新的位置）
 */
static uint8_t buffer_index = 0;

/**
 * @brief 缓冲区填充标志（0=未填满，1=已填满）
 * @note  只有缓冲区填满后，滤波才能发挥最佳效果
 */
static uint8_t buffer_filled = 0;

/* ============================================================================
 *  内部辅助函数
 * ============================================================================ */

/**
 * @brief  冒泡排序（对数组进行升序排序）
 * @param  arr: 要排序的数组
 * @param  len: 数组长度
 * @retval 无
 * @note   这里使用简单的冒泡排序，因为数组很小（通常<10个元素）
 *         对于小数组，冒泡排序的性能足够好，代码也最简单
 *
 * 工作原理：
 * 1. 外层循环控制排序轮数
 * 2. 内层循环进行相邻元素比较和交换
 * 3. 每轮结束后，最大的元素会"冒泡"到末尾
 */
static void bubble_sort(float arr[], uint8_t len)
{
    uint8_t i, j;
    float temp;

    // 外层循环：需要进行 len-1 轮排序
    for (i = 0; i < len - 1; i++)
    {
        // 内层循环：每轮比较相邻元素
        for (j = 0; j < len - 1 - i; j++)
        {
            // 如果前一个元素大于后一个元素，则交换
            if (arr[j] > arr[j + 1])
            {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

/* ============================================================================
 *  对外接口函数
 * ============================================================================ */

/**
 * @brief  中值滤波器初始化
 * @param  init_value: 初始值（用于预填充缓冲区）
 * @retval 无
 * @note   建议在系统启动时调用，用第一次采样值预填充缓冲区
 *         这样可以避免启动初期的数据不稳定
 *
 * 使用示例：
 *     float first_sample = read_sensor();  // 读取第一次采样
 *     median_filter_init(first_sample);     // 初始化滤波器
 */
void median_filter_init(float init_value)
{
    uint8_t i;

    // 用初始值填充整个缓冲区
    for (i = 0; i < MEDIAN_FILTER_WINDOW; i++)
    {
        filter_buffer[i] = init_value;
    }

    // 重置索引和标志
    buffer_index = 0;
    buffer_filled = 1;  // 标记为已填满

    printf("中值滤波器初始化完成，窗口长度=%d，初始值=%.2f\n",
           MEDIAN_FILTER_WINDOW, init_value);
}

/**
 * @brief  中值滤波函数（核心算法）
 * @param  new_value: 新采样的数据
 * @retval 滤波后的数据
 * @note   每次采样后调用此函数，传入最新的采样值
 *
 * 工作流程：
 * 1. 将新采样值存入缓冲区（覆盖最旧的数据）
 * 2. 复制缓冲区数据到临时数组
 * 3. 对临时数组进行排序
 * 4. 取排序后数组的中间值作为输出
 *
 * 使用示例：
 *     float raw_data = read_sensor();           // 读取原始数据
 *     float filtered = median_filter(raw_data); // 滤波处理
 *     printf("滤波后: %.2f\n", filtered);
 */
float median_filter(float new_value)
{
    uint8_t i;
    float temp_buffer[MEDIAN_FILTER_WINDOW];  // 临时数组（用于排序）
    float median_value;

    /* -------------------------------------------------------------------------
     * 步骤1：更新循环缓冲区
     * ------------------------------------------------------------------------- */
    filter_buffer[buffer_index] = new_value;  // 存入新数据
    buffer_index++;                            // 索引前移

    // 如果索引到达末尾，回到起点（循环缓冲）
    if (buffer_index >= MEDIAN_FILTER_WINDOW)
    {
        buffer_index = 0;
        buffer_filled = 1;  // 标记缓冲区已填满
    }

    /* -------------------------------------------------------------------------
     * 步骤2：复制数据到临时数组
     * 为什么要复制？因为排序会改变数组顺序，我们不能破坏原始缓冲区
     * ------------------------------------------------------------------------- */
    for (i = 0; i < MEDIAN_FILTER_WINDOW; i++)
    {
        temp_buffer[i] = filter_buffer[i];
    }

    /* -------------------------------------------------------------------------
     * 步骤3：对临时数组排序
     * ------------------------------------------------------------------------- */
    bubble_sort(temp_buffer, MEDIAN_FILTER_WINDOW);

    /* -------------------------------------------------------------------------
     * 步骤4：取中值
     * 对于奇数个元素，中值就是中间位置的元素
     * 例如：[1, 2, 3, 4, 5] 中值是 temp_buffer[2] = 3
     * ------------------------------------------------------------------------- */
    median_value = temp_buffer[MEDIAN_FILTER_WINDOW / 2];

    return median_value;
}

/**
 * @brief  获取滤波器状态（调试用）
 * @param  无
 * @retval 无
 * @note   打印当前缓冲区的内容，方便调试
 */
void median_filter_debug(void)
{
    uint8_t i;

    printf("\n========== 中值滤波器状态 ==========\n");
    printf("窗口长度: %d\n", MEDIAN_FILTER_WINDOW);
    printf("缓冲区状态: %s\n", buffer_filled ? "已填满" : "未填满");
    printf("当前索引: %d\n", buffer_index);
    printf("缓冲区内容: [");

    for (i = 0; i < MEDIAN_FILTER_WINDOW; i++)
    {
        printf("%.2f", filter_buffer[i]);
        if (i < MEDIAN_FILTER_WINDOW - 1)
        {
            printf(", ");
        }
    }
    printf("]\n");
    printf("===================================\n\n");
}

/* ============================================================================
 *  测试代码（演示如何使用）
 * ============================================================================ */

/**
 * @brief  测试函数1：基础功能测试
 * @note   测试滤波器对稳定信号的处理
 */
void test_stable_signal(void)
{
    printf("\n【测试1】稳定信号测试（无干扰）\n");
    printf("输入序列：25, 25, 25, 25, 25\n");
    printf("期望输出：25（应保持不变）\n\n");

    median_filter_init(25.0f);  // 初始化

    for (int i = 0; i < 5; i++)
    {
        float input = 25.0f;
        float output = median_filter(input);
        printf("第%d次采样 | 输入: %.2f | 输出: %.2f\n", i+1, input, output);
    }
}

/**
 * @brief  测试函数2：脉冲干扰测试
 * @note   测试滤波器对单个突变点的抑制能力
 */
void test_pulse_noise(void)
{
    printf("\n【测试2】脉冲干扰测试\n");
    printf("输入序列：50, 50, 50, 100, 50, 50, 50\n");
    printf("期望效果：第4个数据（100）应该被滤除\n\n");

    float test_data[] = {50, 50, 50, 100, 50, 50, 50};
    median_filter_init(test_data[0]);  // 用第一个值初始化

    for (int i = 0; i < 7; i++)
    {
        float input = test_data[i];
        float output = median_filter(input);
        printf("第%d次采样 | 输入: %.2f | 输出: %.2f", i+1, input, output);

        // 标注异常值
        if (input == 100)
        {
            printf(" ← 异常值，应被滤除");
        }
        printf("\n");
    }
}

/**
 * @brief  测试函数3：信号跳变测试
 * @note   测试滤波器对真实信号跳变的响应速度
 */
void test_step_response(void)
{
    printf("\n【测试3】阶跃响应测试（信号从50跳变到100）\n");
    printf("输入序列：50, 50, 50, 100, 100, 100, 100\n");
    printf("观察点：需要几次采样才能跟踪到新值\n\n");

    float test_data[] = {50, 50, 50, 100, 100, 100, 100};
    median_filter_init(test_data[0]);

    for (int i = 0; i < 7; i++)
    {
        float input = test_data[i];
        float output = median_filter(input);
        printf("第%d次采样 | 输入: %.2f | 输出: %.2f", i+1, input, output);

        // 标注信号跳变点
        if (i == 3)
        {
            printf(" ← 信号跳变点");
        }
        printf("\n");
    }
}

/**
 * @brief  测试函数4：实际传感器模拟
 * @note   模拟温度传感器的实际采样情况（带噪声）
 */
void test_sensor_simulation(void)
{
    printf("\n【测试4】传感器模拟测试（温度传感器）\n");
    printf("场景：室温25度，偶尔受到电磁干扰\n\n");

    // 模拟传感器数据：正常值25±0.5，偶尔出现干扰
    float sensor_data[] = {
        25.1,   // 正常
        25.3,   // 正常
        25.0,   // 正常
        88.5,   // 干扰1（电磁干扰）
        25.2,   // 正常
        25.1,   // 正常
        -10.0,  // 干扰2（传感器瞬间故障）
        25.0,   // 正常
        25.3,   // 正常
        25.2    // 正常
    };

    median_filter_init(sensor_data[0]);

    for (int i = 0; i < 10; i++)
    {
        float input = sensor_data[i];
        float output = median_filter(input);
        printf("第%2d次采样 | 原始值: %6.2f | 滤波后: %6.2f",
               i+1, input, output);

        // 标注异常数据
        if (input > 30 || input < 20)
        {
            printf(" ← 异常值");
        }
        printf("\n");
    }
}

/**
 * @brief  主函数
 */
int main(void)
{
    printf("================================================\n");
    printf("       中值滤波算法测试程序\n");
    printf("================================================\n");
    printf("窗口长度: %d\n", MEDIAN_FILTER_WINDOW);
    printf("================================================\n");

    // 运行各项测试
    test_stable_signal();        // 测试1：稳定信号
    test_pulse_noise();          // 测试2：脉冲干扰
    test_step_response();        // 测试3：阶跃响应
    test_sensor_simulation();    // 测试4：传感器模拟

    // 显示滤波器内部状态（调试）
    median_filter_debug();

    printf("\n================================================\n");
    printf("测试完成！\n");
    printf("================================================\n");

    return 0;
}

/* ============================================================================
 *  使用说明
 * ============================================================================
 *
 * 1. 基本使用流程：
 *    ① 在系统初始化时调用 median_filter_init(初始值)
 *    ② 在每次采样后调用 median_filter(新采样值)
 *    ③ 使用返回的滤波值进行后续处理
 *
 * 2. 参数调节：
 *    修改 MEDIAN_FILTER_WINDOW 宏定义：
 *    - 噪声大 → 增大窗口（如改为7或9）
 *    - 响应慢 → 减小窗口（如改为3）
 *    - 通用场景 → 保持5（推荐值）
 *
 * 3. 移植到嵌入式系统：
 *    ① 复制 median_filter_init() 和 median_filter() 函数
 *    ② 复制 bubble_sort() 辅助函数
 *    ③ 复制全局变量和宏定义
 *    ④ 在主循环中周期性调用 median_filter()
 *
 * 4. 内存占用估算：
 *    - RAM: MEDIAN_FILTER_WINDOW × sizeof(float) + 几个字节
 *    - 例如：窗口5，每个float 4字节 → 约20字节
 *
 * 5. CPU占用估算：
 *    - 主要开销在排序算法
 *    - 窗口5时，冒泡排序约需 10~20 次比较
 *    - 对于一般MCU（如STM32），占用时间 < 10us
 *
 * 6. 常见问题：
 *    Q: 为什么启动时数据不稳定？
 *    A: 缓冲区未填满，建议用初始值预填充（median_filter_init）
 *
 *    Q: 如何判断窗口大小是否合适？
 *    A: 观察滤波后的数据，如果仍有毛刺则增大窗口，如果响应慢则减小窗口
 *
 *    Q: 中值滤波和均值滤波哪个好？
 *    A: 脉冲干扰用中值滤波，高斯噪声用均值滤波，也可以组合使用
 *
 * ============================================================================
 */

/**
 ******************************************************************************
 * 算法性能分析
 * ============================================================================
 *
 * 【时间复杂度】
 * - 冒泡排序: O(n²)，其中 n = MEDIAN_FILTER_WINDOW
 * - 对于 n=5：最多需要 10 次比较
 * - 对于 n=7：最多需要 21 次比较
 *
 * 【空间复杂度】
 * - 需要两个数组：filter_buffer 和 temp_buffer
 * - 总空间: 2 × n × sizeof(float) ≈ 2n × 4 字节
 * - 例如 n=5 时，约需 40 字节 RAM
 *
 * 【优化方向】
 * 1. 如果窗口很大（>10），可以改用快速排序
 * 2. 如果采样频率很高，可以用滑动窗口中值算法（避免每次完全排序）
 * 3. 如果内存紧张，可以用整型数组替代浮点型
 *
 ******************************************************************************
 */
