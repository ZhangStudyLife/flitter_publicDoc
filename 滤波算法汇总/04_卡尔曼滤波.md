# 卡尔曼滤波（Kalman Filter）

## 一、算法原理

### 1.1 什么是卡尔曼滤波？

卡尔曼滤波是一种**最优递归数据处理算法**，由鲁道夫·卡尔曼（Rudolf Kalman）于1960年提出。它可以从一系列不完全且包含噪声的测量数据中，估计动态系统的状态。

**通俗理解**：
想象你在黑暗的房间里扔飞镖，你看不清飞镖的实际位置，只能通过一个有误差的传感器来测量。卡尔曼滤波就像一个聪明的助手，它会：
1. 根据物理规律**预测**飞镖应该在哪里
2. 结合传感器的**测量值**进行修正
3. 综合这两个信息，给出**最优估计**

### 1.2 核心思想

卡尔曼滤波采用"**预测-更新**"的两步策略：

```
┌─────────────┐
│  上一时刻   │
│  最优估计   │
└──────┬──────┘
       │
       ▼
┌─────────────┐      ┌─────────────┐
│  预测步骤   │      │  系统模型   │
│ (根据模型)  │◄─────┤  物理规律   │
└──────┬──────┘      └─────────────┘
       │
       ▼
┌─────────────┐
│  预测值     │
│  (先验估计) │
└──────┬──────┘
       │
       │      ┌─────────────┐
       │      │  传感器     │
       │      │  测量值     │
       │      └──────┬──────┘
       │             │
       ▼             ▼
┌─────────────────────┐
│     更新步骤        │
│  (融合测量值)       │
└──────┬──────────────┘
       │
       ▼
┌─────────────┐
│  当前时刻   │
│  最优估计   │
└─────────────┘
```

### 1.3 数学模型（简化一维版本）

#### 状态方程
系统状态的变化规律：
```
x(k) = x(k-1) + u(k-1) + w(k-1)
```
- `x(k)`：k时刻的真实状态
- `u(k-1)`：控制输入（已知的状态变化）
- `w(k-1)`：过程噪声（系统的不确定性）

#### 观测方程
传感器测量模型：
```
z(k) = x(k) + v(k)
```
- `z(k)`：k时刻的测量值
- `v(k)`：测量噪声（传感器误差）

### 1.4 卡尔曼滤波五个核心公式

**第一步：预测阶段**

**公式1：状态预测**
```
x̂(k|k-1) = x̂(k-1|k-1) + u(k-1)
```
根据上一时刻的最优估计，预测当前状态。

**公式2：协方差预测**
```
P(k|k-1) = P(k-1|k-1) + Q
```
- `P`：估计误差协方差（表示估计的不确定性）
- `Q`：过程噪声协方差（系统模型的不确定性）

**第二步：更新阶段**

**公式3：计算卡尔曼增益**
```
K(k) = P(k|k-1) / (P(k|k-1) + R)
```
- `K`：卡尔曼增益（0~1之间，决定预测和测量的权重）
- `R`：测量噪声协方差（传感器的不确定性）

**卡尔曼增益的含义**：
- 当 `K` 接近 0 时：更相信预测值（传感器不可靠）
- 当 `K` 接近 1 时：更相信测量值（模型不准确）

**公式4：状态更新**
```
x̂(k|k) = x̂(k|k-1) + K(k) × [z(k) - x̂(k|k-1)]
```
融合预测值和测量值，得到最优估计。
- `z(k) - x̂(k|k-1)`：测量残差（预测和测量的差异）

**公式5：协方差更新**
```
P(k|k) = (1 - K(k)) × P(k|k-1)
```
更新估计误差协方差，为下一次迭代做准备。

### 1.5 工作流程示意图

```
时间 k-1                    时间 k
  │                           │
  │  x̂(k-1|k-1)              │
  │  P(k-1|k-1)              │
  │                           │
  └────────┬─────────────────►│
           │                  │
           │  ① 预测          │
           │                  │
           ▼                  │
      x̂(k|k-1) ◄─────────────┤ 预测值
      P(k|k-1)               │
           │                  │
           │  ② 测量          │
           │                  │
           ▼                  │
         z(k) ◄───────────────┤ 传感器
           │                  │
           │  ③ 计算增益      │
           │                  │
           ▼                  │
         K(k)                 │
           │                  │
           │  ④ 更新          │
           │                  │
           ▼                  │
      x̂(k|k) ◄─────────────────┤ 最优估计
      P(k|k)                 │
           │                  │
           └──────────────────┤
                              │
                            下一轮
```

## 二、C语言实现（简化一维卡尔曼滤波）

### 2.1 应用场景示例
假设我们要测量一个恒定电压，但传感器有噪声干扰。使用卡尔曼滤波可以得到更准确的电压估计值。

### 2.2 代码实现
详细代码请参考 `04_卡尔曼滤波.c` 文件。

**核心数据结构**：
```c
typedef struct {
    float x;      // 状态估计值
    float P;      // 估计误差协方差
    float Q;      // 过程噪声协方差
    float R;      // 测量噪声协方差
    float K;      // 卡尔曼增益
} KalmanFilter_t;
```

**核心函数**：
```c
// 初始化滤波器
void Kalman_Init(KalmanFilter_t *kf, float init_x, float init_P,
                 float process_noise, float measure_noise);

// 滤波处理
float Kalman_Filter(KalmanFilter_t *kf, float measurement);
```

### 2.3 使用示例
```c
// 1. 定义滤波器
KalmanFilter_t voltage_filter;

// 2. 初始化（初始值=0, 初始不确定性=1, Q=0.001, R=0.1）
Kalman_Init(&voltage_filter, 0.0f, 1.0f, 0.001f, 0.1f);

// 3. 循环滤波
while (1) {
    float raw_voltage = ADC_Read();  // 读取原始数据
    float filtered = Kalman_Filter(&voltage_filter, raw_voltage);
    printf("滤波后电压: %.2f V\n", filtered);
}
```

## 三、优缺点分析

### 3.1 优点

| 优点 | 说明 |
|------|------|
| **最优估计** | 在线性系统和高斯噪声假设下，提供数学意义上的最优估计 |
| **递归计算** | 只需当前测量值和上一次估计，不需要存储历史数据 |
| **内存效率高** | 内存占用极小，适合嵌入式系统 |
| **实时性好** | 计算量小，可以实时处理数据流 |
| **预测能力** | 不仅能滤波，还能预测未来状态 |
| **自适应性** | 通过卡尔曼增益自动调整预测和测量的权重 |
| **处理多传感器融合** | 可以融合多个传感器的数据（扩展卡尔曼滤波） |

### 3.2 缺点

| 缺点 | 说明 |
|------|------|
| **需要系统模型** | 必须知道系统的状态转移方程（物理规律） |
| **参数调节困难** | Q和R参数需要经验调节，初学者不易掌握 |
| **仅适用线性系统** | 标准卡尔曼滤波只能处理线性系统 |
| **假设高斯噪声** | 要求噪声服从高斯分布，实际可能不满足 |
| **初始值敏感** | 初始估计不当可能导致收敛缓慢 |
| **无法处理突变** | 对于突然的状态跳变，响应可能滞后 |
| **计算复杂度** | 相比简单滤波器，计算量稍大（但仍可接受） |

### 3.3 与其他滤波器对比

```
滤波器性能对比（满分5分）

                滑动平均  中值滤波  限幅滤波  卡尔曼滤波
滤波效果         ★★★     ★★★★    ★★       ★★★★★
响应速度         ★★      ★★★     ★★★★★    ★★★★
计算复杂度       ★★      ★★★★    ★★       ★★★
内存占用         ★★      ★★★     ★★★★★    ★★★★★
易用性           ★★★★★   ★★★★★   ★★★★★    ★★
预测能力         ☆       ☆       ☆        ★★★★★
```

## 四、适用场景

### 4.1 嵌入式系统典型应用

#### 1. **传感器数据融合**
```
应用：融合加速度计、陀螺仪、磁力计数据
场景：无人机姿态估计、机器人导航
优势：多传感器互补，提高精度
```

#### 2. **GPS定位优化**
```
应用：融合GPS和惯性测量单元(IMU)
场景：车载导航、移动机器人定位
优势：GPS信号丢失时仍能预测位置
```

#### 3. **电池电量估计**
```
应用：估计锂电池SOC(State of Charge)
场景：电动汽车、便携设备
优势：比库仑计数法更准确
```

#### 4. **电机速度控制**
```
应用：估计电机实际转速
场景：伺服控制、无刷电机控制
优势：滤除编码器噪声，预测下一时刻速度
```

#### 5. **温度测量**
```
应用：滤除温度传感器噪声
场景：恒温控制、热敏设备
优势：平滑温度曲线，提高控制精度
```

#### 6. **信号跟踪**
```
应用：跟踪目标位置、速度
场景：雷达跟踪、视觉跟踪
优势：预测目标轨迹，处理短暂遮挡
```

### 4.2 适用条件判断

**适合使用卡尔曼滤波**：
- ✓ 系统行为可以用数学模型描述
- ✓ 需要实时处理数据流
- ✓ 内存资源有限
- ✓ 需要预测未来状态
- ✓ 噪声主要是随机高斯噪声

**不太适合卡尔曼滤波**：
- ✗ 系统完全未知，无法建模
- ✗ 存在大量脉冲干扰（考虑中值滤波）
- ✗ 非线性系统且精度要求极高（考虑粒子滤波）
- ✗ 只需要简单平滑（滑动平均更简单）

## 五、参数调节建议

### 5.1 参数说明

| 参数 | 名称 | 物理意义 | 典型范围 |
|------|------|----------|----------|
| **Q** | 过程噪声协方差 | 对系统模型的信任度 | 0.001 ~ 0.1 |
| **R** | 测量噪声协方差 | 对传感器的信任度 | 0.01 ~ 10 |
| **P** | 估计误差协方差 | 当前估计的不确定性 | 初始值1~10 |
| **x** | 初始状态 | 状态的初始猜测值 | 根据实际情况 |

### 5.2 参数调节步骤

#### 第一步：估算测量噪声 R

**方法1：直接测量法**
```c
// 让传感器静止测量多次，计算标准差
float samples[100];
for (int i = 0; i < 100; i++) {
    samples[i] = ADC_Read();
}
float R = calculate_variance(samples, 100);
```

**方法2：经验值**
```
高精度传感器：R = 0.01 ~ 0.1
中等精度传感器：R = 0.1 ~ 1.0
低精度传感器：R = 1.0 ~ 10.0
```

#### 第二步：设置过程噪声 Q

**经验规则**：
```
Q 通常远小于 R (约为 R 的 1/10 ~ 1/100)

如果 R = 0.1，则 Q = 0.001 ~ 0.01
```

**调节方向**：
- **Q 增大** → 更相信测量值 → 响应快，但噪声大
- **Q 减小** → 更相信预测值 → 平滑好，但响应慢

#### 第三步：设置初始值

```c
// 初始状态 x：可以用第一次测量值
float init_x = ADC_Read();

// 初始协方差 P：表示初始不确定性
float init_P = 1.0f;  // 中等不确定性
```

### 5.3 实用调节技巧

#### 技巧1：Q/R 比值法
```
比值          效果
─────────────────────────────────
Q/R = 0.001   极度平滑，响应很慢
Q/R = 0.01    平滑优先，响应较慢
Q/R = 0.1     平衡模式（推荐起点）
Q/R = 1.0     响应优先，略有噪声
Q/R = 10.0    快速响应，噪声明显
```

#### 技巧2：观察卡尔曼增益 K
```c
// 在滤波函数中打印 K 值
printf("Kalman Gain: %.4f\n", kf->K);

// 判断标准：
// K ≈ 0    → 几乎不信任测量，可能 R 太大
// K ≈ 0.5  → 平衡状态（理想）
// K ≈ 1    → 几乎不信任预测，可能 Q 太大
```

#### 技巧3：分阶段调节

**阶段1：求稳定（先让系统工作）**
```c
Q = 0.01f;  // 较小值
R = 1.0f;   // 较大值
// 效果：平滑但响应慢
```

**阶段2：提速度（加快响应）**
```c
Q = 0.1f;   // 逐步增大 Q
R = 1.0f;   // 保持不变
// 观察响应速度是否满足要求
```

**阶段3：降噪声（优化平滑度）**
```c
Q = 0.1f;   // 保持不变
R = 0.5f;   // 逐步减小 R
// 如果噪声增大，说明 R 减小过度
```

### 5.4 常见问题诊断

| 现象 | 可能原因 | 解决方案 |
|------|----------|----------|
| 滤波后仍有噪声 | R 设置过小 | 增大 R 值 |
| 响应速度太慢 | Q 设置过小 | 增大 Q 值 |
| 滤波效果不明显 | Q 过大，几乎等于原始值 | 减小 Q 值 |
| 输出波动异常 | 参数数量级不匹配 | 检查 Q 和 R 的比例关系 |
| 初始收敛慢 | 初始 P 值过小 | 增大初始 P（如设为10） |

### 5.5 自动调参方法（进阶）

对于复杂系统，可以使用自适应卡尔曼滤波：

```c
// 根据最近的残差动态调整 R
float residual = fabs(measurement - kf->x);
if (residual > threshold) {
    kf->R *= 1.2f;  // 测量不可靠，增大 R
} else {
    kf->R *= 0.95f; // 测量可靠，减小 R
}
```

## 六、学习建议

### 6.1 理解层次

**Level 1：会用**
- 掌握初始化和滤波函数的调用
- 能够根据场景设置基本参数

**Level 2：会调**
- 理解五个核心公式的含义
- 能够根据效果调节 Q 和 R 参数

**Level 3：会改**
- 理解数学推导过程
- 能够扩展到多维卡尔曼滤波

### 6.2 实践建议

1. **先仿真后实际**：用Excel或Python生成带噪声数据，验证算法
2. **从一维开始**：先掌握简化版本，再学习扩展卡尔曼滤波(EKF)
3. **对比实验**：与滑动平均等算法对比，理解优势
4. **可视化调试**：绘制原始值、滤波值、卡尔曼增益曲线

### 6.3 扩展学习

- **扩展卡尔曼滤波(EKF)**：处理非线性系统
- **无迹卡尔曼滤波(UKF)**：更高精度的非线性滤波
- **粒子滤波**：处理非高斯噪声

## 七、总结

### 关键要点

1. **核心思想**：预测 + 测量融合 = 最优估计
2. **两大阶段**：预测阶段（时间更新）+ 更新阶段（测量更新）
3. **关键参数**：Q（过程噪声）和 R（测量噪声）
4. **适用条件**：线性系统 + 高斯噪声 + 已知模型

### 一句话总结
卡尔曼滤波是一种**递归最优估计算法**，通过融合系统模型预测和传感器测量，实时给出状态的最优估计，特别适合资源受限的嵌入式系统。

---

**参考资料**：
- Kalman, R. E. (1960). "A New Approach to Linear Filtering and Prediction Problems"
- Welch & Bishop (2006). "An Introduction to the Kalman Filter"
- 《卡尔曼滤波原理及应用》- 付梦印等著
