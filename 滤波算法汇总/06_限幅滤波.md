# 限幅滤波算法详解

## 1. 算法原理

### 1.1 基本思想

限幅滤波（也称为程序判断滤波）是一种最简单直观的滤波方法。它的核心思想是：**在正常情况下，相邻两次采样值的变化不会太大，如果变化超过某个合理范围，则认为这是一个异常值（干扰），应该舍弃。**

可以用生活中的例子来理解：
- 你在测量室温，正常情况下温度变化很慢，比如从25℃到25.5℃
- 如果突然测到一个40℃的值，这显然不合理（可能是传感器受到干扰）
- 此时应该忽略这个异常值，继续使用上一次的有效数据

### 1.2 数学原理

设：
- $x(n)$ 为第 $n$ 次采样值
- $x(n-1)$ 为第 $n-1$ 次采样值（上一次的有效值）
- $A$ 为允许的最大偏差（限幅值）

判断逻辑：

$$
y(n) =
\begin{cases}
x(n), & \text{如果 } |x(n) - x(n-1)| \leq A \\
x(n-1), & \text{如果 } |x(n) - x(n-1)| > A
\end{cases}
$$

用通俗的话说：
- 如果新采样值与上次值的差别在合理范围内（≤A），就接受这个新值
- 如果差别太大（>A），就认为是干扰，继续使用上次的值

### 1.3 工作流程

```
开始
  ↓
读取新的采样值 x(n)
  ↓
计算偏差 Δ = |x(n) - x(n-1)|
  ↓
判断：Δ ≤ A ?
  ↓                    ↓
 是                    否
  ↓                    ↓
接受新值          保留旧值
y(n) = x(n)      y(n) = x(n-1)
  ↓                    ↓
更新历史值 ←─────────┘
x(n-1) = y(n)
  ↓
输出 y(n)
  ↓
结束
```

## 2. C语言实现

详见 `06_限幅滤波.c` 文件。

核心代码结构：
```c
// 限幅滤波函数
float amplitude_limit_filter(float new_value, float *last_value, float limit)
{
    float delta = fabs(new_value - *last_value);

    if (delta <= limit) {
        *last_value = new_value;  // 接受新值
        return new_value;
    } else {
        return *last_value;        // 保留旧值
    }
}
```

## 3. 优缺点分析

### 3.1 优点

| 优点 | 说明 |
|------|------|
| **实现简单** | 只需要一次减法、一次比较，代码量极少 |
| **计算量小** | 不需要复杂的数学运算，适合低性能MCU |
| **内存占用少** | 只需保存一个历史值，几乎不占用RAM |
| **实时性好** | 无延迟，当前输出只依赖当前输入 |
| **消除脉冲干扰** | 对偶然出现的尖峰脉冲干扰效果很好 |
| **无需初始化** | 不需要填充缓冲区，第一次采样即可工作 |

### 3.2 缺点

| 缺点 | 说明 |
|------|------|
| **无法跟踪快速变化** | 如果真实信号变化快，会被误判为干扰而滤除 |
| **参数难以选择** | 限幅值A太大滤波效果差，太小会丢失真实变化 |
| **不能滤除随机噪声** | 对叠加在信号上的小幅度噪声无能为力 |
| **可能产生阶跃** | 连续多次超限后会产生输出停滞现象 |
| **依赖初始值** | 第一个采样值直接作为基准，如果它就是异常值会影响后续 |

### 3.3 典型问题场景

**场景1：信号快速变化**
```
真实温度：25℃ → 30℃ → 35℃ （加热过程）
限幅值 A = 3℃
结果：第二次采样就被拦截，无法跟踪真实变化
```

**解决方法：** 使用改进型限幅滤波（见下文）

**场景2：持续干扰**
```
真实值：25℃
干扰值：每次都+10℃
结果：虽然能滤除，但输出会一直保持旧值
```

## 4. 适用场景

### 4.1 理想应用场景

限幅滤波最适合以下特点的系统：

#### （1）信号变化缓慢
- **温度测量**：室温、水温等变化缓慢的物理量
- **压力监测**：液压系统、气压监测
- **液位检测**：水箱液位、油箱油位
- **湿度监测**：环境湿度变化缓慢

```c
// 示例：温度监测系统
#define TEMP_LIMIT 2.0f  // 温度变化限幅：2℃
float room_temp = 25.0f;
float filtered = amplitude_limit_filter(adc_read_temp(), &room_temp, TEMP_LIMIT);
```

#### （2）偶发性脉冲干扰
- 电源瞬间波动导致的ADC异常
- 电磁干扰引起的偶然尖峰
- 机械振动引起的偶然冲击

#### （3）资源受限的嵌入式系统
- RAM只有几KB的小型MCU
- 需要极快响应速度的控制系统
- 需要同时处理多路传感器的应用

### 4.2 不适用场景

#### （1）快速变化的信号
- **电机转速**：可能瞬间加速或减速
- **加速度传感器**：运动状态变化快
- **音频信号**：频率变化范围大

#### （2）需要精确测量的场合
- 精密仪器仪表
- 科学实验数据采集
- 医疗设备测量

#### （3）信号本身带有随机噪声
- 使用算术平均滤波或中值滤波更合适

## 5. 参数调节建议

### 5.1 限幅值A的选择原则

限幅值的选择是使用该算法的关键，需要综合考虑：

#### 原则1：基于信号特性
$$
A = k \times \Delta x_{max}
$$

其中：
- $\Delta x_{max}$ 是正常情况下的最大变化量
- $k$ 是安全系数，通常取 1.2 ~ 2.0

**示例：温度传感器**
```
采样周期：1秒
正常最大变化率：0.5℃/秒
则：A = 1.5 × 0.5 = 0.75℃
```

#### 原则2：基于噪声统计
如果干扰幅度已知：
$$
A = x_{noise\_max} + 3\sigma
$$

其中：
- $x_{noise\_max}$ 是噪声的最大幅度
- $\sigma$ 是噪声的标准差

#### 原则3：实验测定法
最可靠的方法是通过实验确定：

1. **采集真实数据**：在正常工作条件下采集100组以上数据
2. **统计相邻差值**：计算 $\Delta x = |x(n) - x(n-1)|$
3. **分析分布**：找出99%数据的差值上限
4. **设定限幅值**：$A = \Delta x_{99\%} \times 1.2$

### 5.2 不同应用的参考值

| 应用场景 | 典型限幅值 | 说明 |
|----------|-----------|------|
| 室温监测 | 1~3℃ | 假设1秒采样一次 |
| 水温控制 | 2~5℃ | 取决于加热速度 |
| 压力传感器（慢变） | 量程的1~5% | 如0~100kPa，限幅1~5kPa |
| 液位检测 | 量程的2~10% | 取决于流速 |
| 电池电压 | 0.1~0.5V | 电压变化很慢 |
| 光照强度 | 量程的5~10% | 环境光变化较慢 |

### 5.3 动态调整策略

对于某些应用，可以动态调整限幅值：

```c
// 根据系统状态调整限幅值
float get_adaptive_limit(SystemState state)
{
    switch(state) {
        case STARTUP:
            return 10.0f;   // 启动阶段，放宽限制
        case NORMAL:
            return 2.0f;    // 正常运行，严格限制
        case FAST_CHANGE:
            return 5.0f;    // 快速变化期，适当放宽
        default:
            return 2.0f;
    }
}
```

### 5.4 调试技巧

#### （1）添加诊断输出
```c
float amplitude_limit_filter_debug(float new_value, float *last_value, float limit)
{
    float delta = fabs(new_value - *last_value);

    if (delta > limit) {
        printf("[FILTER] 检测到超限: %.2f → %.2f (Δ=%.2f > %.2f)\n",
               *last_value, new_value, delta, limit);
    }

    // ... 滤波逻辑
}
```

#### （2）统计超限频率
```c
static uint32_t total_count = 0;
static uint32_t reject_count = 0;

total_count++;
if (delta > limit) {
    reject_count++;
    float reject_rate = (float)reject_count / total_count * 100;
    if (reject_rate > 10.0f) {
        printf("[WARNING] 超限率过高: %.1f%%，建议增大限幅值\n", reject_rate);
    }
}
```

**正常情况下：**
- 超限率应该 < 5%（偶发干扰）
- 如果超限率 > 20%，说明限幅值设置过小

#### （3）波形对比
使用串口工具记录原始值和滤波后的值，绘制对比图：
```
时间  原始值  滤波值  是否超限
0     25.0    25.0    N
1     25.2    25.2    N
2     35.0    25.2    Y  ← 检测到脉冲干扰
3     25.3    25.3    N
```

## 6. 改进型算法

### 6.1 改进方向1：自适应限幅

当检测到连续多次超限时，可能是真实信号在快速变化，此时应放宽限制：

```c
float adaptive_amplitude_filter(float new_value, float *last_value,
                                float limit, uint8_t *exceed_count)
{
    float delta = fabs(new_value - *last_value);

    if (delta <= limit) {
        *last_value = new_value;
        *exceed_count = 0;  // 重置超限计数
        return new_value;
    } else {
        (*exceed_count)++;

        // 连续3次超限，可能是真实变化，逐步跟踪
        if (*exceed_count >= 3) {
            *last_value += (new_value > *last_value) ? limit : -limit;
            return *last_value;
        }
        return *last_value;
    }
}
```

### 6.2 改进方向2：结合滑动平均

先用限幅滤除脉冲干扰，再用滑动平均滤除随机噪声：

```c
// 两级滤波
float stage1 = amplitude_limit_filter(raw_value, &last_value, limit);
float stage2 = moving_average_filter(stage1, buffer, N);
```

### 6.3 改进方向3：双阈值判断

设置两个阈值，提高鲁棒性：

```c
#define LIMIT_NORMAL 2.0f   // 正常限幅
#define LIMIT_MAX    5.0f   // 最大限幅

if (delta <= LIMIT_NORMAL) {
    // 小变化，直接接受
    return new_value;
} else if (delta <= LIMIT_MAX) {
    // 中等变化，部分跟踪
    return *last_value + (new_value - *last_value) * 0.5f;
} else {
    // 大变化，拒绝
    return *last_value;
}
```

## 7. 实际应用案例

### 案例1：温度采集系统

**需求：** STM32单片机采集DS18B20温度传感器数据，消除偶尔出现的错误读数。

**分析：**
- DS18B20通信可能受干扰，偶尔读到异常值（如-127℃或85℃）
- 真实温度变化缓慢（< 1℃/秒）
- 采样周期：500ms

**代码：**
```c
#define TEMP_LIMIT 2.0f  // 限幅值：2℃

float last_temp = 25.0f;  // 初始温度

void temperature_task(void)
{
    float raw_temp = DS18B20_Read();
    float filtered_temp = amplitude_limit_filter(raw_temp, &last_temp, TEMP_LIMIT);

    printf("温度: %.1f℃\n", filtered_temp);

    // 温控逻辑
    if (filtered_temp > 30.0f) {
        turn_on_fan();
    }
}
```

### 案例2：电池电压监测

**需求：** 监测锂电池电压，防止ADC读数抖动导致误报警。

**分析：**
- 电池电压变化极慢（放电过程）
- ADC可能有±0.05V的随机误差
- 需要准确判断低电压报警（3.3V）

**代码：**
```c
#define VOLTAGE_LIMIT 0.1f  // 限幅值：0.1V

float last_voltage = 4.2f;  // 满电初始值

void battery_monitor(void)
{
    float raw_voltage = ADC_Read_Voltage();
    float filtered_voltage = amplitude_limit_filter(raw_voltage, &last_voltage, VOLTAGE_LIMIT);

    if (filtered_voltage < 3.3f) {
        low_battery_warning();
    }
}
```

## 8. 总结

### 8.1 关键要点

1. **原理简单**：限幅滤波就是"合理就接受，不合理就拒绝"
2. **适用范围窄**：只适合信号变化缓慢、偶发脉冲干扰的场景
3. **参数是关键**：限幅值的选择直接决定滤波效果
4. **常与其他算法组合**：单独使用效果有限，常作为第一级滤波

### 8.2 选择建议

**使用限幅滤波的条件：**
- ✅ 信号变化缓慢且可预测
- ✅ 主要干扰是偶发的脉冲
- ✅ 系统资源非常有限
- ✅ 需要零延迟响应

**不使用限幅滤波的条件：**
- ❌ 信号变化快速或不可预测
- ❌ 需要滤除随机噪声
- ❌ 需要高精度测量
- ❌ 系统资源充足（可用更好的算法）

### 8.3 学习建议

对于大一新生，建议按以下步骤学习：

1. **理解原理**：先用生活例子理解，再看数学公式
2. **动手实践**：在Keil或STM32CubeIDE中实现代码
3. **仿真测试**：用数组模拟传感器数据，观察滤波效果
4. **参数实验**：改变限幅值，观察输出变化
5. **实际应用**：在真实硬件上测试（如Arduino + 温度传感器）

### 8.4 扩展阅读

- 下一步学习：中值滤波（能滤除脉冲且不丢失快速变化）
- 进阶算法：卡尔曼滤波（最优滤波，但复杂度高）
- 组合应用：限幅 + 一阶滞后 + 滑动平均（三级滤波）

---

**编写日期：** 2025-11-09
**适用对象：** 嵌入式系统开发者、电子信息类专业学生
**难度等级：** ⭐（入门级）
