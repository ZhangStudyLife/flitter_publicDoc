# 一阶低通滤波（RC滤波）详解

## 1. 算法原理

### 1.1 什么是一阶低通滤波？

一阶低通滤波，也叫**RC滤波**或**指数滑动平均滤波**，是最简单、最常用的数字滤波算法之一。它的名字来源于模拟电路中的RC电路（电阻-电容电路）。

**通俗理解**：想象你在看一个不断跳动的数字温度计，读数一会儿23℃，一会儿25℃，让人眼花缭乱。一阶低通滤波就像给这个温度计加了"缓冲"，让数值变化变得平滑，不会那么跳跃。

### 1.2 数学原理

一阶低通滤波的核心公式非常简单：

```
Y(n) = α × X(n) + (1 - α) × Y(n-1)
```

**符号说明**：
- `Y(n)`：第n次滤波后的输出值（本次输出）
- `Y(n-1)`：第n-1次滤波后的输出值（上次输出）
- `X(n)`：第n次采样的原始输入值（本次测量值）
- `α`：滤波系数，取值范围 0 < α ≤ 1

### 1.3 工作机制

这个公式的含义是：**新的输出值 = 本次测量值的一部分 + 上次输出值的一部分**

- 当 `α = 1` 时，`Y(n) = X(n)`，相当于没有滤波，直接输出原始值
- 当 `α` 接近 0 时，新测量值的权重很小，输出变化非常缓慢
- 当 `α = 0.5` 时，新旧值各占一半权重

**形象比喻**：
- α 就像"相信新信息的程度"
- α 大：容易相信新测量值，反应快但容易受噪声影响
- α 小：更相信历史数据，反应慢但更平滑稳定

### 1.4 频域特性

从频域角度看，这个滤波器能够：
- **通过低频信号**：缓慢变化的真实信号能通过
- **抑制高频信号**：快速跳变的噪声被削弱

截止频率公式：

```
fc = α × fs / (2π)
```

其中 `fs` 是采样频率。

### 1.5 参数 α 的选择

α 值通常有两种表示方法：

**方法1：直接系数法**
```
α = 0.1, 0.2, 0.3 ... （直接给定）
```

**方法2：时间常数法（更常用）**
```
α = T / (T + τ)
```
- `T`：采样周期（单位：秒）
- `τ`：滤波时间常数（单位：秒），决定滤波器的"记忆长度"

**经验值**：
- 温度传感器：α = 0.1 ~ 0.2
- 加速度计：α = 0.3 ~ 0.5
- 快速信号：α = 0.5 ~ 0.8

---

## 2. C语言实现

### 2.1 基础版本（单通道）

```c
/**
 * @brief 一阶低通滤波器
 * @param input 本次采样值
 * @param alpha 滤波系数 (0 < alpha <= 1)
 * @return 滤波后的输出值
 */
float FirstOrderLowPassFilter(float input, float alpha)
{
    static float output = 0.0f;  // 保存上次的输出值（静态变量）

    // 核心滤波公式
    output = alpha * input + (1.0f - alpha) * output;

    return output;
}
```

### 2.2 结构体版本（多通道）

当需要对多个传感器同时滤波时，使用结构体更方便：

```c
/**
 * @brief 滤波器结构体
 */
typedef struct {
    float alpha;        // 滤波系数
    float output;       // 上次输出值
    uint8_t is_init;    // 是否已初始化
} LowPassFilter_t;

/**
 * @brief 初始化滤波器
 * @param filter 滤波器指针
 * @param alpha 滤波系数
 * @param init_value 初始值（通常设为第一次测量值）
 */
void LPF_Init(LowPassFilter_t *filter, float alpha, float init_value)
{
    filter->alpha = alpha;
    filter->output = init_value;
    filter->is_init = 1;
}

/**
 * @brief 滤波更新函数
 * @param filter 滤波器指针
 * @param input 本次采样值
 * @return 滤波后的输出值
 */
float LPF_Update(LowPassFilter_t *filter, float input)
{
    // 如果未初始化，用第一次输入值初始化
    if (!filter->is_init) {
        filter->output = input;
        filter->is_init = 1;
        return input;
    }

    // 一阶低通滤波公式
    filter->output = filter->alpha * input + (1.0f - filter->alpha) * filter->output;

    return filter->output;
}
```

### 2.3 完整使用示例

```c
#include <stdio.h>

int main(void)
{
    // 示例1：单通道温度传感器滤波
    float temp_raw = 25.3f;  // 原始温度
    float temp_filtered;

    temp_filtered = FirstOrderLowPassFilter(temp_raw, 0.2f);
    printf("滤波后温度: %.2f℃\n", temp_filtered);


    // 示例2：多通道三轴加速度计滤波
    LowPassFilter_t acc_x, acc_y, acc_z;

    // 初始化三个滤波器
    LPF_Init(&acc_x, 0.3f, 0.0f);
    LPF_Init(&acc_y, 0.3f, 0.0f);
    LPF_Init(&acc_z, 0.3f, 9.8f);  // Z轴初始值设为重力加速度

    // 模拟10次采样
    for (int i = 0; i < 10; i++) {
        // 假设读取到的原始值（含噪声）
        float raw_x = 0.1f + (rand() % 100) / 1000.0f;  // 模拟噪声
        float raw_y = -0.2f + (rand() % 100) / 1000.0f;
        float raw_z = 9.8f + (rand() % 100) / 1000.0f;

        // 滤波处理
        float filtered_x = LPF_Update(&acc_x, raw_x);
        float filtered_y = LPF_Update(&acc_y, raw_y);
        float filtered_z = LPF_Update(&acc_z, raw_z);

        printf("第%d次 - X: %.3f  Y: %.3f  Z: %.3f\n",
               i+1, filtered_x, filtered_y, filtered_z);
    }

    return 0;
}
```

---

## 3. 优缺点分析

### 3.1 优点

| 优点 | 说明 |
|------|------|
| ✅ **算法简单** | 只需一个公式，代码不超过5行 |
| ✅ **计算量小** | 只有1次乘法和2次加减法，单片机轻松运行 |
| ✅ **内存占用低** | 只需保存一个历史值，每个通道仅需4字节 |
| ✅ **实时性好** | 无需存储大量历史数据，可以即时输出 |
| ✅ **参数调节方便** | 只有一个参数α需要调节 |
| ✅ **稳定性好** | 不会出现数值溢出或振荡 |

### 3.2 缺点

| 缺点 | 说明 |
|------|------|
| ❌ **滤波效果一般** | 对强噪声的抑制能力有限 |
| ❌ **相位滞后** | α较小时，输出会明显滞后于输入 |
| ❌ **不能处理突变** | 真实信号突变时，输出跟不上 |
| ❌ **对周期性噪声无效** | 无法去除50Hz工频干扰等周期噪声 |
| ❌ **参数依赖经验** | α值需要根据实际情况多次调试 |

### 3.3 性能对比

```
噪声抑制能力：★★☆☆☆
相位延迟：    ★★★☆☆（α大时好）
计算速度：    ★★★★★
内存占用：    ★★★★★
易用性：      ★★★★★
```

---

## 4. 适用场景

### 4.1 最适合的应用

| 应用场景 | α建议值 | 说明 |
|---------|---------|------|
| 🌡️ **温度传感器** | 0.1 ~ 0.2 | 温度变化慢，可以用小α值 |
| 📏 **距离传感器** | 0.2 ~ 0.3 | 超声波、红外测距等 |
| 🔋 **电池电压监测** | 0.1 ~ 0.15 | 电压变化缓慢 |
| 📡 **ADC数据处理** | 0.3 ~ 0.5 | 去除ADC的读数跳变 |
| 🎮 **摇杆/旋钮** | 0.4 ~ 0.6 | 人机交互，需要平滑手感 |

### 4.2 不适合的应用

❌ **高动态信号**：如快速电机转速、冲击振动
❌ **对延迟敏感**：如高速闭环控制系统
❌ **强噪声环境**：如工业现场的电磁干扰
❌ **需要精确频率特性**：如音频处理

### 4.3 实际项目示例

**智能手环心率监测**：
```c
// 心率传感器数据处理
LowPassFilter_t heart_rate_filter;
LPF_Init(&heart_rate_filter, 0.25f, 75.0f);  // 初始心率75bpm

// 每100ms采样一次
uint16_t raw_hr = Read_HeartRate_Sensor();
float filtered_hr = LPF_Update(&heart_rate_filter, (float)raw_hr);
```

**智能温控系统**：
```c
// 环境温度监测
LowPassFilter_t temp_filter;
LPF_Init(&temp_filter, 0.15f, 25.0f);

// 定时器中每1秒更新
float room_temp = Read_Temperature();
float stable_temp = LPF_Update(&temp_filter, room_temp);
Display_Temperature(stable_temp);  // 显示平滑的温度
```

---

## 5. 参数调节建议

### 5.1 α值选择策略

#### 方法1：根据信号变化速度选择

```
信号变化速度    α值建议
----------------+----------
极慢（温度）     0.05 ~ 0.15
慢（电压）       0.15 ~ 0.25
中等（距离）     0.25 ~ 0.40
快（加速度）     0.40 ~ 0.60
极快（开关）     0.60 ~ 0.90
```

#### 方法2：根据采样频率计算

已知需要的响应时间 `T_resp`（信号变化到稳定值63%所需的时间）：

```
α = T_sample / (T_sample + T_resp)
```

**例子**：
- 采样周期 `T_sample = 100ms`
- 期望响应时间 `T_resp = 500ms`（希望0.5秒内跟上变化）
- 计算：`α = 0.1 / (0.1 + 0.5) = 0.167`

#### 方法3：实验调试法

```c
// 在代码中预留调试接口
#define FILTER_ALPHA  0.2f  // 方便修改测试

// 或者通过串口动态调整
void Set_Filter_Alpha(float new_alpha) {
    if (new_alpha > 0 && new_alpha <= 1.0f) {
        filter.alpha = new_alpha;
    }
}
```

### 5.2 调参经验

**起步建议**：
1. 先从 `α = 0.3` 开始测试
2. 如果输出太跳动 → 减小α（如改为0.2）
3. 如果输出太迟钝 → 增大α（如改为0.5）

**平衡技巧**：
- 噪声大但信号变化慢 → 用小α（0.1~0.2）
- 噪声小但信号变化快 → 用大α（0.5~0.7）
- 想要两者兼顾 → 考虑使用卡尔曼滤波

### 5.3 常见问题排查

| 问题现象 | 可能原因 | 解决方法 |
|---------|---------|---------|
| 输出一直为0 | 未初始化或初始值错误 | 检查 `is_init` 标志 |
| 输出变化太慢 | α值过小 | 增大α到0.3以上 |
| 滤波效果不明显 | α值过大 | 减小α到0.3以下 |
| 输出有延迟 | 这是低通滤波特性 | 适当增大α或换其他算法 |

### 5.4 进阶技巧

**自适应α值**：根据输入变化幅度动态调整

```c
float Adaptive_Alpha(float input, float last_output)
{
    float diff = fabs(input - last_output);

    // 变化小时用小α（平滑），变化大时用大α（快速跟踪）
    if (diff < 1.0f) {
        return 0.1f;  // 平稳期，强滤波
    } else if (diff < 5.0f) {
        return 0.3f;  // 中等变化
    } else {
        return 0.7f;  // 剧烈变化，快速响应
    }
}
```

---

## 6. 总结

### 6.1 核心要点

1. **公式简单**：`Y = α × X + (1-α) × Y_old`
2. **一个参数**：只需调节α值（0~1之间）
3. **适合慢信号**：温度、电压等缓慢变化的场景
4. **有相位滞后**：α越小延迟越大

### 6.2 使用建议

- 📌 **初学者**：直接用 `α = 0.3` 开始实验
- 📌 **项目应用**：根据采样周期和期望响应时间计算α
- 📌 **性能优化**：考虑使用定点数代替浮点数
- 📌 **效果不足**：叠加其他滤波算法（如中值滤波+低通滤波）

### 6.3 下一步学习

如果一阶低通滤波无法满足需求，可以考虑：
- **二阶低通滤波**：更强的滤波效果
- **中值滤波**：去除脉冲噪声
- **卡尔曼滤波**：动态系统的最优估计
- **滑动平均滤波**：更平滑但需要更多内存

---

## 参考资料

- 《数字信号处理》- 高等教育出版社
- 《嵌入式系统数字滤波算法》
- Arduino官方文档：Smoothing Library

---

**文档版本**：v1.0
**最后更新**：2025-01-09
**适用对象**：嵌入式开发者、电子工程专业学生
