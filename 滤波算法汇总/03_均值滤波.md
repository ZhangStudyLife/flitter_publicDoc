# 均值滤波（滑动平均滤波）

## 1. 算法原理

### 1.1 基本概念

均值滤波，也称为滑动平均滤波，是最简单也是最常用的数字滤波算法之一。它的核心思想非常直观：**对最近N次采样值求平均，用平均值作为本次的有效值**。

就像你考试成绩不稳定，老师用最近5次考试的平均分来评估你的真实水平一样，均值滤波通过"平均"来平滑掉数据中的随机波动。

### 1.2 数学原理

假设我们有N个连续的采样值：$x_1, x_2, x_3, ..., x_N$

均值滤波的输出为：

$$y = \frac{1}{N} \sum_{i=1}^{N} x_i = \frac{x_1 + x_2 + x_3 + ... + x_N}{N}$$

其中：
- $y$ 是滤波后的输出值
- $N$ 是参与平均的采样个数（窗口长度）
- $x_i$ 是第i个采样值

### 1.3 工作机制

均值滤波使用一个**循环队列**（也叫滑动窗口）来存储最近N次的采样值：

```
初始状态（N=5）：
窗口：[空, 空, 空, 空, 空]

第1次采样（值=10）：
窗口：[10, 空, 空, 空, 空]
输出：10 / 1 = 10

第2次采样（值=12）：
窗口：[10, 12, 空, 空, 空]
输出：(10+12) / 2 = 11

第3次采样（值=8）：
窗口：[10, 12, 8, 空, 空]
输出：(10+12+8) / 3 = 10

第4次采样（值=15）：
窗口：[10, 12, 8, 15, 空]
输出：(10+12+8+15) / 4 = 11.25

第5次采样（值=9）：
窗口：[10, 12, 8, 15, 9]  ← 窗口填满
输出：(10+12+8+15+9) / 5 = 10.8

第6次采样（值=11）：
窗口：[11, 12, 8, 15, 9]  ← 最旧的10被11替换
       ↑ 新值替换最旧值
输出：(11+12+8+15+9) / 5 = 11
```

每次新数据到来时：
1. **旧数据出队**：丢弃最旧的一个数据
2. **新数据入队**：将新采样值加入队列
3. **计算平均**：对队列中所有数据求平均

### 1.4 形象比喻

想象你在观察河流的水位：
- **不用滤波**：每秒记录一次，数据跳来跳去（水波起伏）
- **均值滤波**：用最近10秒的平均水位作为当前水位，数据变得平滑（忽略了短暂波动）

窗口长度N就像你的"记忆时间"：
- N=3：只记住最近3秒，反应快但容易受干扰
- N=20：记住最近20秒，很稳定但反应慢

---

## 2. C语言实现

### 2.1 实现方式对比

均值滤波有两种经典实现方式：

| 方式 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| **方式一：每次遍历求和** | 代码简单，易理解 | 效率低（每次都遍历） | 窗口很小（N<5）时 |
| **方式二：增量更新** | 效率高（只计算差值） | 代码稍复杂 | 窗口较大或调用频繁时 |

代码中两种方式都有实现，可以对比学习。

### 2.2 完整代码

详见配套的 `03_均值滤波.c` 文件，包含：
- 两种实现方式
- 完整的测试代码
- 详细的注释说明

### 2.3 关键参数

```c
#define FILTER_N 12  // 窗口长度，决定滤波效果
```

**参数调节原则**：
- **N值越大** → 滤波效果越好，但响应越慢
- **N值越小** → 响应越快，但滤波效果越差

---

## 3. 优缺点分析

### 3.1 优点

| 优点 | 说明 |
|------|------|
| ✅ **算法简单** | 只需要加法和除法，初中数学水平即可理解 |
| ✅ **实现容易** | 代码量少，不易出错，适合新手 |
| ✅ **资源占用小** | 只需N个数据的存储空间 |
| ✅ **平滑效果好** | 对周期性干扰滤波效果显著 |
| ✅ **适用面广** | 几乎所有需要平滑的场合都能用 |

### 3.2 缺点

| 缺点 | 说明 | 影响 |
|------|------|------|
| ❌ **响应速度慢** | 新数据要等N次采样才能完全体现 | 快速变化的信号会"拖尾" |
| ❌ **相位滞后** | 输出比输入延迟 N/2 个采样周期 | 控制系统可能失稳 |
| ❌ **灵敏度降低** | 对突变信号反应迟钝 | 可能错过重要的快速变化 |
| ❌ **对脉冲干扰无效** | 单个脉冲干扰会持续影响N次 | 需要配合其他算法 |

### 3.3 典型问题示例

**问题1：响应滞后**
```
真实温度快速上升：20°C → 30°C（突然加热）
均值滤波输出（N=10）：
  20.0 → 21.0 → 22.0 → ... → 30.0（需要10次采样才接近真实值）
```

**问题2：脉冲干扰残留**
```
正常数据：25, 25, 25, 25, 25...
突然来一个干扰：25, 25, 100, 25, 25...

滤波输出（N=5）：
25 → 25 → 32 → 35 → 35 → 32 → 25
      ↑                    ↑
   干扰出现            干扰影响持续5次
```

---

## 4. 适用场景

### 4.1 ✅ 适合使用的场景

| 场景 | 原因 | 典型应用 |
|------|------|----------|
| **变化缓慢的信号** | 不需要快速响应 | 温度监测、湿度监测、气压测量 |
| **周期性干扰** | 平均可抵消周期波动 | 电源纹波、工频干扰 |
| **数据平滑显示** | 人眼观察更舒适 | 仪表显示、LED数码管 |
| **低精度要求** | 简单够用即可 | 粗略监测、指示灯控制 |

**典型案例**：
```c
// 温度监测（每秒采样一次，温度变化慢）
float temp = read_temperature();
float filtered_temp = average_filter(temp);  // N=10，平滑10秒
display(filtered_temp);  // 显示稳定的温度值
```

### 4.2 ❌ 不适合使用的场景

| 场景 | 原因 | 应使用 |
|------|------|--------|
| **快速变化的信号** | 响应太慢 | 限幅滤波、一阶滞后 |
| **控制系统反馈** | 相位滞后导致不稳定 | 卡尔曼滤波、互补滤波 |
| **脉冲干扰严重** | 无法有效去除 | 中位值滤波、去极值平均 |
| **高精度测量** | 精度损失大 | 中位值滤波、递推平均 |

**反例**：
```c
// ❌ 错误使用：电机速度控制
float speed_error = target_speed - current_speed;
float filtered_error = average_filter(speed_error);  // 延迟严重！
motor_output = PID_control(filtered_error);  // 可能导致震荡
```

### 4.3 实际工程案例

#### 案例1：智能家居温度采集 ✅
```c
// 室内温度监测（DHT11传感器）
// 传感器精度：±2°C，采样间隔：2秒
// 分析：温度变化慢，精度要求不高，适合均值滤波

#define TEMP_FILTER_N 5  // 平滑10秒（5次×2秒）

float room_temp = dht11_read_temperature();
float smooth_temp = average_filter(room_temp);

if (smooth_temp > 28.0) {
    turn_on_fan();  // 开启风扇
}
```

#### 案例2：电池电压监测 ✅
```c
// 锂电池电压采集（电压变化慢）
// ADC噪声：±50mV，采样间隔：100ms
// 分析：电压变化慢，周期性噪声，适合均值滤波

#define VOLTAGE_FILTER_N 20  // 平滑2秒（20次×100ms）

float battery_voltage = read_adc_voltage();
float stable_voltage = average_filter(battery_voltage);

if (stable_voltage < 3.3) {
    low_battery_warning();  // 低电量警告
}
```

#### 案例3：光照强度监测 ✅
```c
// 环境光强度采集（用于自动调节屏幕亮度）
// 光敏电阻噪声大，但光照变化慢
// 分析：人眼对缓慢变化不敏感，适合均值滤波

#define LIGHT_FILTER_N 15  // 平滑1.5秒

float light_intensity = read_light_sensor();
float smooth_light = average_filter(light_intensity);

screen_brightness = map(smooth_light, 0, 1000, 10, 100);
```

---

## 5. 参数调节建议

### 5.1 窗口长度N的选择

#### 基本原则

$$N = \frac{期望平滑时间}{采样周期}$$

**示例**：
- 采样周期 = 100ms
- 希望平滑1秒的数据
- N = 1000ms / 100ms = 10

#### 经验参考表

| 应用场景 | 采样周期 | 推荐N值 | 平滑时间 |
|----------|----------|---------|----------|
| 温度监测（DS18B20） | 1秒 | 5-10 | 5-10秒 |
| 电压监测（ADC） | 100ms | 10-20 | 1-2秒 |
| 光照强度 | 200ms | 10-15 | 2-3秒 |
| 压力传感器 | 50ms | 20-40 | 1-2秒 |
| 距离测量（超声波） | 100ms | 5-8 | 0.5-0.8秒 |

### 5.2 调节步骤

**第1步：确定基准值**
```c
// 从经验值开始
#define FILTER_N 10
```

**第2步：观察效果**
- 数据还是跳动？→ 增大N
- 反应太慢？→ 减小N
- 观察实际波形最直观

**第3步：实测调优**
```c
// 可以做成可调参数，方便调试
uint8_t filter_n = 10;  // 通过串口或按键调节

void set_filter_n(uint8_t n) {
    if (n >= 2 && n <= 50) {
        filter_n = n;
    }
}
```

**第4步：极限测试**
- 测试最快变化：N值够不够小？
- 测试最大噪声：N值够不够大？
- 找到折衷点

### 5.3 特殊技巧

#### 技巧1：自适应窗口

根据信号变化速度动态调整N：

```c
float adaptive_average_filter(float new_value) {
    static float last_value = 0;
    float change_rate = fabs(new_value - last_value);

    uint8_t adaptive_n;
    if (change_rate > 5.0) {
        adaptive_n = 3;   // 快速变化时，小窗口
    } else {
        adaptive_n = 15;  // 稳定时，大窗口
    }

    last_value = new_value;
    return average_filter_with_n(new_value, adaptive_n);
}
```

#### 技巧2：加权平均

新数据权重更大，老数据权重更小：

```c
// 简单加权：最新的数据算2次
y = (x[0] + x[1] + x[2] + ... + x[N-2] + x[N-1]*2) / (N+1)
```

#### 技巧3：组合滤波

均值滤波 + 其他算法：

```c
// 先去脉冲干扰，再平均
float value = read_sensor();
value = limit_filter(value);      // 先限幅
value = average_filter(value);    // 再平均
```

### 5.4 常见错误

| 错误 | 后果 | 正确做法 |
|------|------|----------|
| ❌ N=1 | 完全没有滤波 | 至少N≥3 |
| ❌ N过大（>100） | 反应极慢，占内存 | 根据采样周期计算 |
| ❌ N不是2的幂次 | 除法慢（单片机） | 优先选2,4,8,16,32 |
| ❌ 未初始化缓冲区 | 第一次结果错误 | 用首次采样值填充 |

### 5.5 性能优化建议

#### 优化1：使用位移代替除法（N为2的幂次时）

```c
// N=16时
// 慢：sum / 16
// 快：sum >> 4  （右移4位等于除以16）

#define FILTER_N 16
y = sum >> 4;  // 比除法快很多
```

#### 优化2：整数运算代替浮点

```c
// 如果精度允许，全用整数
uint16_t sum = 0;
for (int i = 0; i < N; i++) {
    sum += value_buf[i];  // 整数加法
}
uint16_t result = sum >> 4;  // 整数位移
```

#### 优化3：增量更新（避免重复求和）

```c
// 每次只更新差值，不重新求和
sum = sum - value_buf[index] + new_value;
```

---

## 6. 总结

### 6.1 一句话总结

> 均值滤波就像"求考试平均分"，简单好用，适合变化慢的信号，但反应慢是它的致命缺陷。

### 6.2 使用决策树

```
是否需要滤波？
  ├─ 否 → 直接使用原始值
  └─ 是 → 信号变化快吗？
         ├─ 快 → ❌ 不用均值滤波（用限幅、一阶滞后）
         └─ 慢 → 有脉冲干扰吗？
                ├─ 有 → ❌ 不用均值滤波（用中位值）
                └─ 没有 → ✅ 使用均值滤波
```

### 6.3 记忆口诀

```
均值滤波像求平均，
窗口越大越平缓。
温度湿度光照度，
缓慢信号是首选。

快速变化别使用，
脉冲干扰也不管。
N值选择看周期，
平滑时间心中算。
```

### 6.4 与其他滤波算法对比

| 算法 | 复杂度 | 响应速度 | 平滑效果 | 适用场景 |
|------|--------|----------|----------|----------|
| **均值滤波** | ⭐ 简单 | ⭐⭐ 慢 | ⭐⭐⭐ 好 | 缓慢变化信号 |
| 中位值滤波 | ⭐⭐ 中等 | ⭐⭐ 慢 | ⭐⭐ 中等 | 脉冲干扰 |
| 限幅滤波 | ⭐ 简单 | ⭐⭐⭐ 快 | ⭐ 差 | 快速变化 |
| 一阶滞后 | ⭐⭐ 中等 | ⭐⭐⭐ 快 | ⭐⭐ 中等 | 综合场景 |
| 卡尔曼滤波 | ⭐⭐⭐⭐⭐ 复杂 | ⭐⭐⭐⭐ 很快 | ⭐⭐⭐⭐⭐ 很好 | 高精度系统 |

---

## 7. 扩展阅读

### 7.1 数学背景

均值滤波本质上是一个**低通滤波器**（Low Pass Filter），它的频率响应为：

$$H(f) = \frac{sin(\pi f N T)}{\pi f N T}$$

其中T是采样周期，这是一个sinc函数，意味着它能通过低频信号，衰减高频信号。

### 7.2 改进算法

1. **加权移动平均**：新数据权重更大
2. **指数移动平均**：用递推公式，节省内存
3. **自适应滤波**：根据信号特性动态调整参数

### 7.3 实际产品应用

- 小米体温计：温度显示平滑
- Arduino气象站：气压、湿度平滑
- 智能手环：心率数据平滑
- 无人机：气压计高度融合

---

**文档版本**：v1.0
**更新日期**：2025年
**适用人群**：嵌入式初学者、单片机开发者
**配套代码**：03_均值滤波.c
